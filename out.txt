Err(
    SyntaxError {
        source: "// Copyright (c) Microsoft. All rights reserved.\r\n\r\n#ifdef __cplusplus\r\n#include <cstdlib>\r\n#include <cstdint>\r\n#include <cinttypes>\r\n#else\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include <inttypes.h>\r\n#endif\r\n\r\n#include \"windows.h\"\r\n\r\n#define MB * 1024 * 1024\r\n\r\n#include \"macro_utils/macro_utils.h\"\r\n\r\n#include \"real_gballoc_ll.h\"\r\nstatic void* my_gballoc_malloc(size_t size)\r\n{\r\n    return real_gballoc_ll_malloc(size);\r\n}\r\n\r\nstatic void my_gballoc_free(void* ptr)\r\n{\r\n     real_gballoc_ll_free(ptr);\r\n}\r\n\r\n\r\n#include \"testrunnerswitcher.h\"\r\n#include \"umock_c/umock_c.h\"\r\n#include \"umock_c/umocktypes_stdint.h\"\r\n#include \"umock_c/umocktypes_bool.h\"\r\n#include \"umock_c/umocktypes_charptr.h\"\r\n#include \"umock_c/umocktypes.h\"\r\n#include \"umock_c/umock_c_negative_tests.h\"\r\n#include \"c_pal/string_utils.h\"\r\n\r\n#include \"c_pal/interlocked.h\" /*included for mocking reasons - it will prohibit creation of mocks belonging to interlocked.h - at the moment verified through int tests - this is porting legacy code, temporary solution*/\r\n\r\n#define ENABLE_MOCKS\r\n#include \"clds/clds_hazard_pointers.h\"\r\n#undef ENABLE_MOCKS\r\n\r\n#include \"clds/clds_sorted_list.h\"\r\n\r\n#define ENABLE_MOCKS\r\n#include \"c_pal/gballoc_hl.h\"\r\n#include \"c_pal/gballoc_hl_redirect.h\"\r\n#include \"c_pal/timer.h\"\r\n\r\n#include \"c_util/constbuffer.h\"\r\n#include \"c_util/constbuffer_array.h\"\r\n#include \"c_util/memory_data.h\"\r\n#include \"c_util/rc_string.h\"\r\n#include \"c_util/rc_string_array.h\"\r\n#include \"c_util/thandle.h\"\r\n#include \"c_util/uuid.h\"\r\n\r\n#include \"clds/clds_hash_table.h\"\r\n#include \"clds/clds_hazard_pointers.h\"\r\n\r\n#include \"hash.h\"\r\n#include \"bs_disk_space_tracker.h\"\r\n#include \"bs_operation_address.h\"\r\n#include \"bsi_builder.h\"\r\n#include \"bsi_disk_space_reserver.h\"\r\n#include \"bsi_local_block.h\"\r\n#include \"bsi_local_value.h\"\r\n#include \"azure_messaging_metrics/azure_messaging_metric_context.h\"\r\n#include \"azure_messaging_metrics/azure_messaging_metric.h\"\r\n#include \"bsol_if.h\"\r\n#include \"bsol.h\"\r\n#include \"offload_store_interface.h\"\r\n#undef ENABLE_MOCKS\r\n\r\n// Must include umock_c_prod so mocks are not expanded in real_rc_string\r\n#include \"umock_c/umock_c_prod.h\"\r\n\r\n#include \"c_logging/xlogging.h\"\r\n#include \"real_refcount.h\"\r\n#include \"c_util/thandle.h\"\r\n\r\n#include \"real_gballoc_hl.h\"\r\n#include \"real_constbuffer.h\"\r\n#include \"real_constbuffer_array.h\"\r\n#include \"real_memory_data.h\"\r\n#include \"real_rc_string.h\"\r\n#include \"real_rc_string_array.h\"\r\n\r\n#include \"bsi_local_metrics.h\"\r\n#include \"../reals/real_clds_hash_table.h\"\r\n#include \"../reals/real_clds_hazard_pointers.h\"\r\n#include \"uuid_test_type.h\"\r\n\r\n#include \"bsi_local.h\"\r\n\r\nstatic TEST_MUTEX_HANDLE test_serialize_mutex;\r\n\r\nstatic COMPUTE_HASH_FUNC saved_compute_hash;\r\nstatic KEY_COMPARE_FUNC saved_key_compare_func;\r\nstatic BS_DISK_SPACE_TRACKER_HANDLE test_disk_space_tracker = (BS_DISK_SPACE_TRACKER_HANDLE)0x1111;\r\nstatic BSI_LOCAL_BLOCK_HANDLE test_bsi_local_block = (BSI_LOCAL_BLOCK_HANDLE)0x4242;\r\nstatic BSI_LOCAL_BLOCK_HANDLE test_bsi_local_block_2 = (BSI_LOCAL_BLOCK_HANDLE)0x4243;\r\nstatic BSI_LOCAL_BLOCK_APPEND_HANDLE test_block_append_1 = (BSI_LOCAL_BLOCK_APPEND_HANDLE)0x4244;\r\nstatic BSI_LOCAL_BLOCK_APPEND_HANDLE test_block_append_2 = (BSI_LOCAL_BLOCK_APPEND_HANDLE)0x4245;\r\n\r\nstatic AZURE_MESSAGING_METRIC_CONTEXT_HANDLE test_metric_context = (AZURE_MESSAGING_METRIC_CONTEXT_HANDLE)0x1234;\r\nstatic TIMER_HANDLE test_timer = (TIMER_HANDLE)0xDEAD;\r\nstatic BSI_LOCAL_VALUE_HANDLE test_bsi_local_value = (BSI_LOCAL_VALUE_HANDLE)0x424A;\r\nstatic BSI_LOCAL_VALUE_HANDLE test_bsi_local_value_2 = (BSI_LOCAL_VALUE_HANDLE)0x424B;\r\nstatic volatile_atomic int64_t test_append_sequence_number;\r\nstatic HASH_TABLE_SKIPPED_SEQ_NO_CB saved_hash_table_skipped_seq_no_cb[2];\r\nstatic void* saved_hash_table_skipped_seq_no_cb_context[2];\r\nstatic size_t saved_hash_table_skipped_seq_no_index;\r\nstatic BSI_LOCAL_BLOCK_SKIPPED_SEQ_NO_CB saved_bsi_local_block_skipped_seq_no_cb;\r\nstatic void* saved_bsi_local_block_skipped_seq_no_cb_context;\r\nstatic AZURE_MESSAGING_METRIC_HANDLE* metrics;\r\n\r\nstatic BSI_BUILDER_HANDLE test_bsi_builder = (BSI_BUILDER_HANDLE)0xAA01;\r\nstatic BSOL_IF test_bsol_if = (BSOL_IF)0xAA02;\r\nstatic BSOL_HANDLE test_bsol = (BSOL_HANDLE)0x2222;\r\nstatic OFFLOAD_STORE_IF test_offload_store = (OFFLOAD_STORE_IF)0x3333;\r\n\r\nstatic UUID_T test_incarnation_id = {\r\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\r\n    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10\r\n};\r\n\r\nstatic UUID_T test_incarnation_id2 = {\r\n    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,\r\n    0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x10\r\n};\r\n\r\nstatic UUID_T test_etag = {\r\n    0x64, 0x6F, 0x6E, 0x27, 0x74, 0x20, 0x70, 0x61,\r\n    0x6E, 0x69, 0x63, 0x30, 0x30, 0x30, 0x30, 0x30\r\n};\r\n\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_operation_address;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_create_operation_address;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_set_value_operation_address;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_remove_value_operation_address;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_set_block_epoch_operation_address;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_previous_set_block_epoch_address;\r\n#define MAX_OPERATION_ADDRESS_ARRAY_SIZE 10\r\nstatic uint32_t test_operation_address_array_count;\r\nstatic BS_OPERATION_ADDRESS_HANDLE test_operation_address_array[MAX_OPERATION_ADDRESS_ARRAY_SIZE];\r\n\r\nstatic volatile_atomic int64_t test_sequence_number;\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\nMOCK_FUNCTION_WITH_CODE(, DWORD, mocked_TlsAlloc)\r\nMOCK_FUNCTION_END(TlsAlloc())\r\nMOCK_FUNCTION_WITH_CODE(, BOOL, mocked_TlsFree, DWORD, dwTlsIndex)\r\nMOCK_FUNCTION_END(TlsFree(dwTlsIndex))\r\nMOCK_FUNCTION_WITH_CODE(, LPVOID, mocked_TlsGetValue, DWORD, dwTlsIndex)\r\nMOCK_FUNCTION_END(TlsGetValue(dwTlsIndex))\r\nMOCK_FUNCTION_WITH_CODE(, BOOL, mocked_TlsSetValue, DWORD, dwTlsIndex, LPVOID, lpTlsValue)\r\nMOCK_FUNCTION_END(TlsSetValue(dwTlsIndex, lpTlsValue))\r\nMOCK_FUNCTION_WITH_CODE(, void, test_skipped_seq_no_cb, void*, context, int64_t, skipped_seq_no)\r\nMOCK_FUNCTION_END()\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_RESULT_VALUES);\r\n\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(CLDS_HASH_TABLE_INSERT_RESULT, CLDS_HASH_TABLE_INSERT_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(CLDS_HASH_TABLE_INSERT_RESULT, CLDS_HASH_TABLE_INSERT_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(CLDS_HASH_TABLE_DELETE_RESULT, CLDS_HASH_TABLE_DELETE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(CLDS_HASH_TABLE_DELETE_RESULT, CLDS_HASH_TABLE_DELETE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(CLDS_HASH_TABLE_REMOVE_RESULT, CLDS_HASH_TABLE_REMOVE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(CLDS_HASH_TABLE_REMOVE_RESULT, CLDS_HASH_TABLE_REMOVE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(CLDS_HASH_TABLE_SET_VALUE_RESULT, CLDS_HASH_TABLE_SET_VALUE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(CLDS_HASH_TABLE_SET_VALUE_RESULT, CLDS_HASH_TABLE_SET_VALUE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_BLOCK_APPEND_RESULT, BSI_LOCAL_BLOCK_APPEND_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_BLOCK_APPEND_RESULT, BSI_LOCAL_BLOCK_APPEND_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_BLOCK_SEAL_RESULT, BSI_LOCAL_BLOCK_SEAL_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_BLOCK_SEAL_RESULT, BSI_LOCAL_BLOCK_SEAL_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_RESULT_VALUES);\r\nTEST_DEFINE_ENUM_TYPE(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT_VALUES);\r\n\r\nMU_DEFINE_ENUM_STRINGS(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT_VALUES)\r\nMU_DEFINE_ENUM_STRINGS(BSI_LOCAL_BLOCK_APPEND_RESULT, BSI_LOCAL_BLOCK_APPEND_RESULT_VALUES)\r\nMU_DEFINE_ENUM_STRINGS(BSI_LOCAL_BLOCK_SEAL_RESULT, BSI_LOCAL_BLOCK_SEAL_RESULT_VALUES)\r\n\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT_VALUES)\r\nMU_DEFINE_ENUM_STRINGS(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT_VALUES)\r\n\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT_VALUES);\r\nMU_DEFINE_ENUM_STRINGS(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT_VALUES);\r\n\r\nTEST_DEFINE_ENUM_TYPE(BS_OPERATION_ADDRESS_COMPARE_RESULT, BS_OPERATION_ADDRESS_COMPARE_RESULT_VALUES);\r\nIMPLEMENT_UMOCK_C_ENUM_TYPE(BS_OPERATION_ADDRESS_COMPARE_RESULT, BS_OPERATION_ADDRESS_COMPARE_RESULT_VALUES);\r\nMU_DEFINE_ENUM_STRINGS(BS_OPERATION_ADDRESS_COMPARE_RESULT, BS_OPERATION_ADDRESS_COMPARE_RESULT_VALUES);\r\n\r\nMU_DEFINE_ENUM_STRINGS(UMOCK_C_ERROR_CODE, UMOCK_C_ERROR_CODE_VALUES)\r\n\r\n/*\r\n * This struct definition has been taken from bsi_local.c. If the struct\r\n * definition there changes, then this one here better change too.\r\n */\r\ntypedef struct INDEX_VALUE_TAG\r\n{\r\n    char* key;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    volatile_atomic int32_t value_state; // BSI_LOCAL_VALUE_STATE\r\n    CLDS_HASH_TABLE_ITEM* replaced_item;\r\n} INDEX_VALUE;\r\nDECLARE_HASH_TABLE_NODE_TYPE(INDEX_VALUE);\r\n\r\nstatic void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\r\n{\r\n    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\r\n}\r\n\r\n\r\ntypedef struct TEST_BS_OPERATION_ADDRESS_TAG\r\n{\r\n    uint32_t id;\r\n} TEST_BS_OPERATION_ADDRESS;\r\n\r\nDEFINE_REFCOUNT_TYPE_WITH_CUSTOM_ALLOC(TEST_BS_OPERATION_ADDRESS, my_gballoc_malloc, my_gballoc_free);\r\n\r\nstatic BS_OPERATION_ADDRESS_HANDLE create_test_bs_operation_address(uint32_t id)\r\n{\r\n    TEST_BS_OPERATION_ADDRESS* test_address = (TEST_BS_OPERATION_ADDRESS*)REFCOUNT_TYPE_CREATE(TEST_BS_OPERATION_ADDRESS);\r\n    ASSERT_IS_NOT_NULL(test_address);\r\n    test_address->id = id;\r\n    return (BS_OPERATION_ADDRESS_HANDLE)test_address;\r\n}\r\n\r\nstatic void hook_bs_operation_address_inc_ref(BS_OPERATION_ADDRESS_HANDLE bs_operation_address)\r\n{\r\n    TEST_BS_OPERATION_ADDRESS* test_address = (TEST_BS_OPERATION_ADDRESS*)bs_operation_address;\r\n    INC_REF(TEST_BS_OPERATION_ADDRESS, test_address);\r\n}\r\n\r\nstatic void hook_bs_operation_address_dec_ref(BS_OPERATION_ADDRESS_HANDLE bs_operation_address)\r\n{\r\n    TEST_BS_OPERATION_ADDRESS* test_address = (TEST_BS_OPERATION_ADDRESS*)bs_operation_address;\r\n    if (DEC_REF(TEST_BS_OPERATION_ADDRESS, (TEST_BS_OPERATION_ADDRESS*)test_address) == 0)\r\n    {\r\n        REFCOUNT_TYPE_DESTROY(TEST_BS_OPERATION_ADDRESS, (TEST_BS_OPERATION_ADDRESS*)test_address);\r\n    }\r\n}\r\n\r\nstatic BS_OPERATION_ADDRESS_COMPARE_RESULT hook_bs_operation_address_compare(BS_OPERATION_ADDRESS_HANDLE lhs, BS_OPERATION_ADDRESS_HANDLE rhs)\r\n{\r\n    TEST_BS_OPERATION_ADDRESS* test_lhs = (TEST_BS_OPERATION_ADDRESS*)lhs;\r\n    TEST_BS_OPERATION_ADDRESS* test_rhs = (TEST_BS_OPERATION_ADDRESS*)rhs;\r\n\r\n    LogVerbose(\"Mock compare %\" PRIu32 \" with %\" PRIu32,\r\n        test_lhs->id, test_rhs->id);\r\n\r\n    if (test_lhs->id > test_rhs->id)\r\n    {\r\n        return BS_OPERATION_ADDRESS_GREATER_THAN;\r\n    }\r\n    else if (test_lhs->id > test_rhs->id)\r\n    {\r\n        return BS_OPERATION_ADDRESS_LESS_THAN;\r\n    }\r\n    else\r\n    {\r\n        return BS_OPERATION_ADDRESS_EQUAL;\r\n    }\r\n}\r\n\r\nstatic AZURE_MESSAGING_METRIC_HANDLE hook_azure_messaging_metric_create(AZURE_MESSAGING_METRIC_CONTEXT_HANDLE metric_context, const char* metric_namespace, const char* metric_name)\r\n{\r\n    (void)metric_context;\r\n    (void)metric_namespace;\r\n    (void)metric_name;\r\n    return (AZURE_MESSAGING_METRIC_HANDLE)my_gballoc_malloc(1);\r\n}\r\n\r\nstatic void hook_azure_messaging_metric_destroy(AZURE_MESSAGING_METRIC_HANDLE metric)\r\n{\r\n    my_gballoc_free(metric);\r\n}\r\n\r\nstatic CLDS_HASH_TABLE_HANDLE my_clds_hash_table_create(COMPUTE_HASH_FUNC compute_hash, KEY_COMPARE_FUNC key_compare_func, size_t initial_bucket_size, CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers, volatile_atomic int64_t* start_sequence_number, HASH_TABLE_SKIPPED_SEQ_NO_CB skipped_seq_no_cb, void* skipped_seq_no_cb_context)\r\n{\r\n    saved_compute_hash = compute_hash;\r\n    saved_key_compare_func = key_compare_func;\r\n    saved_hash_table_skipped_seq_no_cb[saved_hash_table_skipped_seq_no_index] = skipped_seq_no_cb;\r\n    saved_hash_table_skipped_seq_no_cb_context[saved_hash_table_skipped_seq_no_index++] = skipped_seq_no_cb_context;\r\n\r\n    return real_clds_hash_table_create(compute_hash, key_compare_func, initial_bucket_size, clds_hazard_pointers, start_sequence_number, skipped_seq_no_cb, skipped_seq_no_cb_context);\r\n}\r\n\r\nstatic int my_hash_compute_hash(const void* buffer, size_t length, uint32_t* hash)\r\n{\r\n    (void)buffer;\r\n    (void)length;\r\n    *hash = 0x42;\r\n    return 0;\r\n}\r\n\r\nstatic BSI_LOCAL_BLOCK_APPEND_RESULT my_bsi_local_block_start_append(BSI_LOCAL_BLOCK_HANDLE bsi_local_block, uint32_t append_size, bool check_epoch, uint64_t epoch, BSI_LOCAL_BLOCK_APPEND_HANDLE* append_handle, int64_t* append_sequence_number)\r\n{\r\n    (void)bsi_local_block;\r\n    (void)append_size;\r\n    (void)check_epoch;\r\n    (void)epoch;\r\n    *append_handle = test_block_append_1;\r\n    *append_sequence_number = interlocked_increment_64(&test_append_sequence_number);\r\n    return BSI_LOCAL_BLOCK_APPEND_OK;\r\n}\r\n\r\nstatic int my_bsi_local_block_abort_append(BSI_LOCAL_BLOCK_HANDLE bsi_local_block, uint64_t append_offset, int64_t* delete_append_sequence_no)\r\n{\r\n    (void)bsi_local_block;\r\n    (void)append_offset;\r\n    *delete_append_sequence_no = interlocked_increment_64(&test_append_sequence_number);\r\n    return 0;\r\n}\r\n\r\nstatic int my_bsi_local_block_append_get_offset(BSI_LOCAL_BLOCK_APPEND_HANDLE append_handle, uint64_t* offset)\r\n{\r\n    (void)append_handle;\r\n    *offset = 0;\r\n    return 0;\r\n}\r\n\r\nstatic BSI_LOCAL_BLOCK_HANDLE my_bsi_local_block_create(uint64_t block_size, const UUID_T incarnation_id, CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers, DWORD tls_slot, volatile_atomic int64_t* sequence_no, BSI_LOCAL_BLOCK_SKIPPED_SEQ_NO_CB skipped_seq_no_cb, void* skipped_seq_no_cb_context)\r\n{\r\n    (void)block_size;\r\n    (void)incarnation_id;\r\n    (void)clds_hazard_pointers;\r\n    (void)tls_slot;\r\n    (void)sequence_no;\r\n    saved_bsi_local_block_skipped_seq_no_cb = skipped_seq_no_cb;\r\n    saved_bsi_local_block_skipped_seq_no_cb_context = skipped_seq_no_cb_context;\r\n    return test_bsi_local_block;\r\n}\r\n\r\nstatic BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT my_bsi_local_block_create_from_buffer(BSI_BUILDER_HANDLE bsi_builder, BSOL_IF bsol_if, const unsigned char* buffer, uint64_t buffer_size, CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers, DWORD tls_slot, volatile_atomic int64_t* sequence_no, BSI_LOCAL_BLOCK_SKIPPED_SEQ_NO_CB skipped_seq_no_cb, void* skipped_seq_no_cb_context, BSI_LOCAL_BLOCK_HANDLE* block)\r\n{\r\n    (void)bsi_builder;\r\n    (void)bsol_if;\r\n    (void)buffer;\r\n    (void)buffer_size;\r\n    (void)clds_hazard_pointers;\r\n    (void)tls_slot;\r\n    (void)sequence_no;\r\n    (void)skipped_seq_no_cb_context;\r\n\r\n    ASSERT_IS_NOT_NULL(skipped_seq_no_cb);\r\n    *block = test_bsi_local_block;\r\n\r\n    return BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK;\r\n}\r\n\r\nUUID_T* g_bsi_local_block_get_incarnation_id_incarnation_id = &test_incarnation_id;\r\nstatic int my_bsi_local_block_get_incarnation_id(BSI_LOCAL_BLOCK_HANDLE bsi_local_block, UUID_T* incarnation_id)\r\n{\r\n    (void)bsi_local_block;\r\n    (void)memcpy(*incarnation_id, *g_bsi_local_block_get_incarnation_id_incarnation_id, sizeof(*g_bsi_local_block_get_incarnation_id_incarnation_id));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic const unsigned char bsi_local_block_write_to_buffer_data[4] = { 0xBA, 0xDA, 0xBA, 0xDA };\r\nstatic CONSTBUFFER_HANDLE my_bsi_local_block_write_to_buffer(BSI_LOCAL_BLOCK_HANDLE bsi_local_block, BS_OPERATION_ADDRESS_HANDLE maximum_address)\r\n{\r\n    (void)bsi_local_block;\r\n    (void)maximum_address;\r\n\r\n    CONSTBUFFER_HANDLE buffer = real_CONSTBUFFER_Create(bsi_local_block_write_to_buffer_data, sizeof(bsi_local_block_write_to_buffer_data));\r\n    ASSERT_IS_NOT_NULL(buffer);\r\n    return buffer;\r\n}\r\n\r\nUUID_T* g_bsi_local_value_get_incarnation_id_incarnation_id = &test_incarnation_id;\r\nstatic int my_bsi_local_value_get_incarnation_id(BSI_LOCAL_VALUE_HANDLE bsi_local_value, UUID_T* incarnation_id)\r\n{\r\n    (void)bsi_local_value;\r\n    (void)memcpy(*incarnation_id, *g_bsi_local_value_get_incarnation_id_incarnation_id, sizeof(*g_bsi_local_value_get_incarnation_id_incarnation_id));\r\n\r\n    return 0;\r\n}\r\n\r\nUUID_T* g_bsi_local_value_get_etag = &test_etag;\r\nstatic int my_bsi_local_value_get_etag(BSI_LOCAL_VALUE_HANDLE bsi_local_value, UUID_T* etag)\r\n{\r\n    (void)bsi_local_value;\r\n    (void)memcpy(*etag, *g_bsi_local_value_get_etag, sizeof(*g_bsi_local_value_get_etag));\r\n\r\n    return 0;\r\n}\r\n\r\nstatic BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT my_bsi_local_value_create_from_buffer(BSI_BUILDER_HANDLE bsi_builder, BSOL_IF bsol_if, const unsigned char* buffer, uint64_t buffer_size, BSI_LOCAL_VALUE_HANDLE* value)\r\n{\r\n    (void)bsi_builder;\r\n    (void)bsol_if;\r\n    (void)buffer;\r\n    (void)buffer_size;\r\n\r\n    *value = test_bsi_local_value;\r\n\r\n    return BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK;\r\n}\r\n\r\nstatic int my_bsi_local_value_get_operation_address(BSI_LOCAL_VALUE_HANDLE bsi_local_value, BS_OPERATION_ADDRESS_HANDLE* operation_address)\r\n{\r\n    (void)bsi_local_value;\r\n    *operation_address = test_set_value_operation_address;\r\n\r\n    return 0;\r\n}\r\n\r\nstatic const unsigned char bsi_local_value_write_to_buffer_data[4] = { 0xFA, 0xBA, 0xDA, 0xFA };\r\nstatic CONSTBUFFER_HANDLE my_bsi_local_value_write_to_buffer(BSI_LOCAL_VALUE_HANDLE bsi_local_value)\r\n{\r\n    (void)bsi_local_value;\r\n\r\n    CONSTBUFFER_HANDLE buffer = real_CONSTBUFFER_Create(bsi_local_value_write_to_buffer_data, sizeof(bsi_local_value_write_to_buffer_data));\r\n    ASSERT_IS_NOT_NULL(buffer);\r\n    return buffer;\r\n}\r\n\r\nstatic void setup_bsi_local_create_metrics_expectations(void)\r\n{\r\n    size_t metric_count = AZURE_MESSAGING_METRIC_COUNT(BSI_LOCAL_METRICS);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    for (size_t i = 0; i < metric_count; i++)\r\n    {\r\n        STRICT_EXPECTED_CALL(azure_messaging_metric_create(test_metric_context, MU_TOSTRING(BSI_LOCAL_METRICS), MU_ENUM_TO_STRING(BSI_LOCAL_METRICS, (BSI_LOCAL_METRICS)i)))\r\n            .SetFailReturn(NULL)\r\n            .CaptureReturn(&metrics[i]);\r\n    }\r\n}\r\n\r\nstatic BSI_LOCAL_HANDLE setup_bsi_local_create(DWORD* tls_slot, CLDS_HASH_TABLE_HANDLE* hash_table, CLDS_HASH_TABLE_HANDLE* kvp_hash_table)\r\n{\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create());\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_create_new());\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(bsi_local);\r\n    umock_c_reset_all_calls();\r\n\r\n    return bsi_local;\r\n}\r\n\r\nstatic BSI_LOCAL_HANDLE setup_bsi_local_create_with_hp(DWORD* tls_slot, CLDS_HASH_TABLE_HANDLE* hash_table, CLDS_HASH_TABLE_HANDLE* kvp_hash_table, CLDS_HAZARD_POINTERS_HANDLE* clds_hazard_pointers)\r\n{\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(kvp_hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    return bsi_local;\r\n}\r\n\r\nstatic void test_create_buffers_to_load(uint32_t block_count, uint32_t value_count, CONSTBUFFER_ARRAY_HANDLE* block_buffers, CONSTBUFFER_ARRAY_HANDLE* value_buffers)\r\n{\r\n    uint32_t block_buffer_count = block_count * 2;\r\n    CONSTBUFFER_HANDLE* block_buffers_temp = (CONSTBUFFER_HANDLE*)my_gballoc_malloc(sizeof(CONSTBUFFER_HANDLE) * block_buffer_count);\r\n    ASSERT_IS_NOT_NULL(block_buffers_temp);\r\n\r\n    uint32_t block_buffer_index = 0;\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        char block_id[32];\r\n        (void)sprintf(block_id, \"block_%\" PRIu32, i);\r\n        uint32_t block_id_buffer_size = (uint32_t)(sizeof(uint16_t) + strlen(block_id) + 1);\r\n        unsigned char* block_id_buffer = (unsigned char*)my_gballoc_malloc(block_id_buffer_size);\r\n        ASSERT_IS_NOT_NULL(block_id_buffer);\r\n\r\n        real_write_uint16_t(block_id_buffer, (uint16_t)strlen(block_id) + 1);\r\n        strcpy((char*)(block_id_buffer + sizeof(uint16_t)), block_id);\r\n\r\n        block_buffers_temp[block_buffer_index] = real_CONSTBUFFER_CreateWithMoveMemory(block_id_buffer, block_id_buffer_size);\r\n        ASSERT_IS_NOT_NULL(block_buffers_temp[block_buffer_index]);\r\n        ++block_buffer_index;\r\n\r\n        block_buffers_temp[block_buffer_index] = real_CONSTBUFFER_Create(NULL, 0);\r\n        ASSERT_IS_NOT_NULL(block_buffers_temp[block_buffer_index]);\r\n        ++block_buffer_index;\r\n    }\r\n\r\n    *block_buffers = real_constbuffer_array_create_with_move_buffers(block_buffers_temp, block_buffer_count);\r\n    ASSERT_IS_NOT_NULL(*block_buffers);\r\n\r\n    uint32_t value_buffer_count = value_count * 2;\r\n    CONSTBUFFER_HANDLE* value_buffers_temp = (CONSTBUFFER_HANDLE*)my_gballoc_malloc(sizeof(CONSTBUFFER_HANDLE) * value_buffer_count);\r\n    ASSERT_IS_NOT_NULL(value_buffers_temp);\r\n\r\n    uint32_t value_buffer_index = 0;\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        char key[32];\r\n        (void)sprintf(key, \"key_%\" PRIu32, i);\r\n        uint32_t key_buffer_size = (uint32_t)(sizeof(uint16_t) + strlen(key) + 1);\r\n        unsigned char* key_buffer = (unsigned char*)my_gballoc_malloc(key_buffer_size);\r\n        ASSERT_IS_NOT_NULL(key_buffer);\r\n\r\n        real_write_uint16_t(key_buffer, (uint16_t)strlen(key) + 1);\r\n        strcpy((char*)(key_buffer + sizeof(uint16_t)), key);\r\n\r\n        value_buffers_temp[value_buffer_index] = real_CONSTBUFFER_CreateWithMoveMemory(key_buffer, key_buffer_size);\r\n        ASSERT_IS_NOT_NULL(value_buffers_temp[value_buffer_index]);\r\n        ++value_buffer_index;\r\n\r\n        value_buffers_temp[value_buffer_index] = real_CONSTBUFFER_Create(NULL, 0);\r\n        ASSERT_IS_NOT_NULL(value_buffers_temp[value_buffer_index]);\r\n        ++value_buffer_index;\r\n    }\r\n\r\n    *value_buffers = real_constbuffer_array_create_with_move_buffers(value_buffers_temp, value_buffer_count);\r\n    ASSERT_IS_NOT_NULL(*value_buffers);\r\n}\r\n\r\nstatic CONSTBUFFER_ARRAY_HANDLE test_shrink_one_buffer_in_array(CONSTBUFFER_ARRAY_HANDLE original, uint32_t buffer_index)\r\n{\r\n    uint32_t total_buffers;\r\n    (void)real_constbuffer_array_get_buffer_count(original, &total_buffers);\r\n    CONSTBUFFER_HANDLE* buffers = (CONSTBUFFER_HANDLE*)my_gballoc_malloc(sizeof(CONSTBUFFER_HANDLE) * total_buffers);\r\n    ASSERT_IS_NOT_NULL(buffers);\r\n\r\n    for (uint32_t i = 0; i < total_buffers; ++i)\r\n    {\r\n        if (i == buffer_index)\r\n        {\r\n            const CONSTBUFFER* original_buffer = real_constbuffer_array_get_buffer_content(original, i);\r\n            buffers[i] = real_CONSTBUFFER_Create(original_buffer->buffer, (original_buffer->size > 0) ? original_buffer->size - 1 : 0);\r\n            ASSERT_IS_NOT_NULL(buffers[i]);\r\n        }\r\n        else\r\n        {\r\n            buffers[i] = real_constbuffer_array_get_buffer(original, i);\r\n        }\r\n    }\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE result = real_constbuffer_array_create_with_move_buffers(buffers, total_buffers);\r\n    ASSERT_IS_NOT_NULL(result);\r\n\r\n    return result;\r\n}\r\n\r\nstatic CONSTBUFFER_ARRAY_HANDLE test_replace_one_buffer_in_array(CONSTBUFFER_ARRAY_HANDLE original, uint32_t buffer_index, CONSTBUFFER_HANDLE replacement)\r\n{\r\n    uint32_t total_buffers;\r\n    (void)real_constbuffer_array_get_buffer_count(original, &total_buffers);\r\n    CONSTBUFFER_HANDLE* buffers = (CONSTBUFFER_HANDLE*)my_gballoc_malloc(sizeof(CONSTBUFFER_HANDLE) * total_buffers);\r\n    ASSERT_IS_NOT_NULL(buffers);\r\n\r\n    for (uint32_t i = 0; i < total_buffers; ++i)\r\n    {\r\n        if (i == buffer_index)\r\n        {\r\n            real_CONSTBUFFER_IncRef(replacement);\r\n            buffers[i] = replacement;\r\n        }\r\n        else\r\n        {\r\n            buffers[i] = real_constbuffer_array_get_buffer(original, i);\r\n        }\r\n    }\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE result = real_constbuffer_array_create_with_move_buffers(buffers, total_buffers);\r\n    ASSERT_IS_NOT_NULL(result);\r\n\r\n    return result;\r\n}\r\n\r\nstatic void ignore_expected_calls(void)\r\n{\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG))\r\n        .CallCannotFail()\r\n        .IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG))\r\n        .IgnoreAllCalls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CallCannotFail()\r\n        .IgnoreAllCalls();\r\n}\r\n\r\nstatic void setup_expectation_load_from_buffer_header(DWORD tls_slot, CONSTBUFFER_ARRAY_HANDLE local_block_buffers, CONSTBUFFER_ARRAY_HANDLE local_value_buffers)\r\n{\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_block_buffers, IGNORED_ARG))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_value_buffers, IGNORED_ARG))\r\n        .CallCannotFail();\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG));\r\n}\r\n\r\nstatic void setup_expectation_load_from_buffer_read_block(\r\n    DWORD tls_slot,\r\n    CONSTBUFFER_ARRAY_HANDLE buffers,\r\n    uint32_t block_id_buffer_index,\r\n    uint32_t block_buffer_index,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item)\r\n{\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(buffers, block_id_buffer_index))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(buffers, block_buffer_index))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table_item);\r\n}\r\n\r\nstatic void setup_expectation_load_from_buffer_read_value(\r\n    CONSTBUFFER_ARRAY_HANDLE buffers,\r\n    uint32_t key_buffer_index,\r\n    uint32_t value_buffer_index,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item)\r\n{\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(buffers, key_buffer_index))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(buffers, value_buffer_index))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table_item);\r\n}\r\n\r\nstatic void setup_expectation_load_from_buffer_write_block(\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    const char* block_id,\r\n    bool is_sealed,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item,\r\n    int64_t expected_next_seq_no,\r\n    uint32_t block_count)\r\n{\r\n    static uint32_t space_to_reserve = 8192;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&is_sealed, sizeof(is_sealed))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(bsi_disk_space_reserver_get_additional_space_required_for_allocate(test_disk_space_tracker, test_bsol, test_offload_store, block_id, is_sealed, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_space_to_reserve(&space_to_reserve, sizeof(space_to_reserve));\r\n    STRICT_EXPECTED_CALL(bs_disk_space_tracker_force_reserve(test_disk_space_tracker, 0, space_to_reserve));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .CallCannotFail()\r\n        .ValidateArgumentValue_item(hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, (void*)block_id, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(hash_table_item);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], block_count))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n}\r\n\r\nstatic void setup_expectation_load_from_buffer_write_value(\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    const char* key,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item,\r\n    int64_t expected_next_seq_no,\r\n    uint32_t value_count)\r\n{\r\n    static uint32_t space_to_reserve = 12288;\r\n    STRICT_EXPECTED_CALL(bsi_disk_space_reserver_get_additional_space_required_for_set_value(test_disk_space_tracker, test_bsol, test_offload_store, key, false, false, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_space_to_reserve(&space_to_reserve, sizeof(space_to_reserve));\r\n    STRICT_EXPECTED_CALL(bs_disk_space_tracker_force_reserve(test_disk_space_tracker, 0, space_to_reserve));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .CallCannotFail()\r\n        .ValidateArgumentValue_item(hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, (void*)key, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(hash_table_item);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], value_count))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n}\r\n\r\nstatic void test_fill_index_with_prefix(BSI_LOCAL_HANDLE bsi_local, uint32_t block_count, const char* block_prefix, uint32_t value_count, const char* key_prefix)\r\n{\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        char block_id[32];\r\n        (void)sprintf(block_id, \"%s_%\" PRIu32, block_prefix, i);\r\n        BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, block_id, test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n        ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, (BS_OPERATION_ADDRESS_HANDLE)((size_t)test_operation_address + i)));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        char key[32];\r\n        (void)sprintf(key, \"%s_%\" PRIu32, key_prefix, i);\r\n        BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n        BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, key, test_incarnation_id, NULL, &index_update_action_set_value, &replaced_value));\r\n        ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, (BS_OPERATION_ADDRESS_HANDLE)((size_t)test_set_value_operation_address + 1000 + i)));\r\n        ASSERT_IS_NULL(replaced_value);\r\n    }\r\n}\r\n\r\nstatic void test_fill_index(BSI_LOCAL_HANDLE bsi_local, uint32_t block_count, uint32_t value_count)\r\n{\r\n    test_fill_index_with_prefix(bsi_local, block_count, \"block\", value_count, \"key\");\r\n}\r\n\r\nstatic void test_fill_index_with_second_not_committed(BSI_LOCAL_HANDLE bsi_local, uint32_t block_count, uint32_t value_count, BSI_LOCAL_ACTION_HANDLE* index_update_action_create_block_to_abort, BSI_LOCAL_ACTION_HANDLE* index_update_action_set_value_to_abort)\r\n{\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        char block_id[32];\r\n        (void)sprintf(block_id, \"block_%\" PRIu32, i);\r\n        BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, block_id, test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n\r\n        if (i == 1)\r\n        {\r\n            *index_update_action_create_block_to_abort = index_update_action_create_block;\r\n        }\r\n        else\r\n        {\r\n            ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        char key[32];\r\n        (void)sprintf(key, \"key_%\" PRIu32, i);\r\n        BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n        BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, key, test_incarnation_id, NULL, &index_update_action_set_value, &replaced_value));\r\n        ASSERT_IS_NULL(replaced_value);\r\n\r\n        if (i == 1)\r\n        {\r\n            *index_update_action_set_value_to_abort = index_update_action_set_value;\r\n        }\r\n        else\r\n        {\r\n            ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n        }\r\n    }\r\n}\r\n\r\nstatic void test_delete_items_uncommitted_with_prefix(BSI_LOCAL_HANDLE bsi_local, uint32_t block_count, const char* block_prefix, uint32_t value_count, const char* key_prefix, BSI_LOCAL_ACTION_HANDLE** delete_actions)\r\n{\r\n    BSI_LOCAL_ACTION_HANDLE* delete_actions_temp = my_gballoc_malloc(sizeof(BSI_LOCAL_ACTION_HANDLE) * (block_count + value_count));\r\n    ASSERT_IS_NOT_NULL(delete_actions_temp);\r\n\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        char block_id[32];\r\n        (void)sprintf(block_id, \"%s_%\" PRIu32, block_prefix, i);\r\n        bool was_sealed;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, block_id, test_incarnation_id, &(delete_actions_temp[i]), &was_sealed));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        char key[32];\r\n        (void)sprintf(key, \"%s_%\" PRIu32, key_prefix, i);\r\n        BSI_LOCAL_VALUE_HANDLE removed_value;\r\n\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, key, NULL, NULL, &(delete_actions_temp[block_count + i]), &removed_value));\r\n        ASSERT_IS_NOT_NULL(removed_value);\r\n    }\r\n\r\n    *delete_actions = delete_actions_temp;\r\n}\r\n\r\nstatic void test_delete_items_uncommitted(BSI_LOCAL_HANDLE bsi_local, uint32_t block_count, uint32_t value_count, BSI_LOCAL_ACTION_HANDLE** delete_actions)\r\n{\r\n    test_delete_items_uncommitted_with_prefix(bsi_local, block_count, \"block\", value_count, \"key\", delete_actions);\r\n}\r\n\r\nstatic void expect_take_snapshot_with_items_filtered_out(\r\n    DWORD tls_slot,\r\n    bool has_hazard_pointers,\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table,\r\n    uint32_t block_count,\r\n    uint32_t first_block_to_filter,\r\n    uint32_t blocks_to_filter,\r\n    uint32_t value_count,\r\n    uint32_t first_value_to_filter,\r\n    uint32_t values_to_filter,\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address,\r\n    bool check_addresses)\r\n{\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CallCannotFail();\r\n    if (!has_hazard_pointers)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(kvp_hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        bool filter = false;\r\n\r\n        ASSERT_IS_TRUE(test_operation_address_array_count < MAX_OPERATION_ADDRESS_ARRAY_SIZE, \"Increase MAX_OPERATION_ADDRESS_ARRAY_SIZE for test\");\r\n\r\n        if (i >= first_block_to_filter && i < first_block_to_filter + blocks_to_filter)\r\n        {\r\n            filter = true;\r\n            test_operation_address_array[test_operation_address_array_count] = create_test_bs_operation_address(999999 + i);\r\n        }\r\n        else\r\n        {\r\n            test_operation_address_array[test_operation_address_array_count] = create_test_bs_operation_address(i);\r\n        }\r\n\r\n        if (maximum_address)\r\n        {\r\n            if (!filter || check_addresses)\r\n            {\r\n                STRICT_EXPECTED_CALL(bsi_local_block_get_allocate_operation_address(test_bsi_local_block))\r\n                    .SetReturn(test_operation_address_array[test_operation_address_array_count]);\r\n                STRICT_EXPECTED_CALL(bs_operation_address_compare(test_operation_address_array[test_operation_address_array_count], maximum_address));\r\n                STRICT_EXPECTED_CALL(bs_operation_address_dec_ref(test_operation_address_array[test_operation_address_array_count]));\r\n            }\r\n        }\r\n\r\n        if (filter)\r\n        {\r\n            STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n        }\r\n\r\n        test_operation_address_array_count++;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        bool filter = false;\r\n\r\n        ASSERT_IS_TRUE(test_operation_address_array_count < MAX_OPERATION_ADDRESS_ARRAY_SIZE, \"Increase MAX_OPERATION_ADDRESS_ARRAY_SIZE for test\");\r\n\r\n        if (i >= first_value_to_filter && i < first_value_to_filter + values_to_filter)\r\n        {\r\n            filter = true;\r\n            test_operation_address_array[test_operation_address_array_count] = create_test_bs_operation_address(999999 + i);\r\n        }\r\n        else\r\n        {\r\n            test_operation_address_array[test_operation_address_array_count] = create_test_bs_operation_address(i);\r\n        }\r\n\r\n        if (maximum_address)\r\n        {\r\n            if (!filter || check_addresses)\r\n            {\r\n                STRICT_EXPECTED_CALL(bsi_local_value_get_operation_address(test_bsi_local_value, IGNORED_ARG))\r\n                    .CopyOutArgumentBuffer_operation_address(&test_operation_address_array[test_operation_address_array_count], sizeof(test_operation_address_array[test_operation_address_array_count]));\r\n                STRICT_EXPECTED_CALL(bs_operation_address_compare(test_operation_address_array[test_operation_address_array_count], maximum_address));\r\n                STRICT_EXPECTED_CALL(bs_operation_address_dec_ref(test_operation_address_array[test_operation_address_array_count]));\r\n            }\r\n        }\r\n\r\n        if (filter)\r\n        {\r\n            STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n        }\r\n\r\n        test_operation_address_array_count++;\r\n    }\r\n\r\n    if (maximum_address != NULL)\r\n    {\r\n        STRICT_EXPECTED_CALL(bs_operation_address_inc_ref(maximum_address));\r\n    }\r\n}\r\n\r\nstatic void expect_take_snapshot(DWORD tls_slot, bool has_hazard_pointers, CLDS_HASH_TABLE_HANDLE hash_table, CLDS_HASH_TABLE_HANDLE kvp_hash_table, uint32_t block_count, uint32_t value_count, BS_OPERATION_ADDRESS_HANDLE maximum_address)\r\n{\r\n    expect_take_snapshot_with_items_filtered_out(tls_slot, has_hazard_pointers, hash_table, kvp_hash_table, block_count, 0, 0, value_count, 0, 0, maximum_address, true);\r\n}\r\n\r\nstatic BSI_LOCAL_SNAPSHOT_HANDLE test_take_snapshot(\r\n    BSI_LOCAL_HANDLE bsi_local,\r\n    DWORD tls_slot,\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table,\r\n    uint32_t block_count,\r\n    uint32_t value_count)\r\n{\r\n    test_fill_index(bsi_local, block_count, value_count);\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, (block_count != 0 || value_count != 0), hash_table, kvp_hash_table, block_count, value_count, maximum_address);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    umock_c_reset_all_calls();\r\n\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n\r\n    return snapshot;\r\n}\r\n\r\nstatic BSI_LOCAL_SNAPSHOT_HANDLE test_take_snapshot_and_filter(\r\n    BSI_LOCAL_HANDLE bsi_local,\r\n    DWORD tls_slot,\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table,\r\n    uint32_t block_count,\r\n    uint32_t blocks_to_filter,\r\n    uint32_t value_count,\r\n    uint32_t values_to_filter,\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address)\r\n{\r\n    test_fill_index(bsi_local, block_count, value_count);\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n\r\n    expect_take_snapshot_with_items_filtered_out(tls_slot, (block_count != 0 || value_count != 0), hash_table, kvp_hash_table, block_count, 0, blocks_to_filter, value_count, 0, values_to_filter, maximum_address, true);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    umock_c_reset_all_calls();\r\n\r\n    return snapshot;\r\n}\r\n\r\nstatic void expect_write_snapshot_to_buffers(uint32_t block_count, uint32_t value_count, uint32_t* block_buffer_count_expected, uint32_t* value_buffer_count_expected, BS_OPERATION_ADDRESS_HANDLE maximum_address)\r\n{\r\n    *block_buffer_count_expected = block_count * 2;\r\n    *value_buffer_count_expected = value_count * 2;\r\n\r\n    if (block_count > 0)\r\n    {\r\n        STRICT_EXPECTED_CALL(malloc(sizeof(CONSTBUFFER_HANDLE) * (*block_buffer_count_expected)));\r\n    }\r\n    if (value_count > 0)\r\n    {\r\n        STRICT_EXPECTED_CALL(malloc(sizeof(CONSTBUFFER_HANDLE) * (*value_buffer_count_expected)));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        uint32_t expected_size = sizeof(uint16_t) + 8 /*strlen(block_X)*/;\r\n        STRICT_EXPECTED_CALL(malloc(expected_size));\r\n        STRICT_EXPECTED_CALL(write_uint16_t(IGNORED_ARG, 8));\r\n        STRICT_EXPECTED_CALL(CONSTBUFFER_CreateWithMoveMemory(IGNORED_ARG, expected_size));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_write_to_buffer(test_bsi_local_block, maximum_address));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        uint32_t expected_size = sizeof(uint16_t) + 6 /*strlen(key_X)*/;\r\n        STRICT_EXPECTED_CALL(malloc(expected_size));\r\n        STRICT_EXPECTED_CALL(write_uint16_t(IGNORED_ARG, 6));\r\n        STRICT_EXPECTED_CALL(CONSTBUFFER_CreateWithMoveMemory(IGNORED_ARG, expected_size));\r\n        STRICT_EXPECTED_CALL(bsi_local_value_write_to_buffer(test_bsi_local_value));\r\n    }\r\n\r\n    if (block_count > 0)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_create_with_move_buffers(IGNORED_ARG, *block_buffer_count_expected));\r\n    }\r\n    else\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_create_empty());\r\n    }\r\n    if (value_count > 0)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_create_with_move_buffers(IGNORED_ARG, *value_buffer_count_expected));\r\n    }\r\n    else\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_create_empty());\r\n    }\r\n}\r\n\r\nstatic void expect_get_list(CLDS_HASH_TABLE_HANDLE hash_table, uint32_t items_in_list, uint32_t items_in_snapshot)\r\n{\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(rc_string_array_create(items_in_list));\r\n\r\n    for (uint32_t i = 0; i < items_in_list; ++i)\r\n    {\r\n        // Ignore args because we can't guarantee the order\r\n        STRICT_EXPECTED_CALL(rc_string_create(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(THANDLE_MOVE(RC_STRING)(IGNORED_ARG, IGNORED_ARG));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < items_in_snapshot; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n}\r\n\r\nstatic void validate_data_written_to_buffers(\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers,\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers,\r\n    uint32_t starting_block,\r\n    uint32_t block_count,\r\n    uint32_t block_buffer_count,\r\n    uint32_t starting_key,\r\n    uint32_t value_count,\r\n    uint32_t value_buffer_count)\r\n{\r\n    ASSERT_IS_NOT_NULL(block_buffers);\r\n    ASSERT_IS_NOT_NULL(value_buffers);\r\n\r\n    uint32_t count;\r\n    (void)real_constbuffer_array_get_buffer_count(block_buffers, &count);\r\n    ASSERT_ARE_EQUAL(uint32_t, block_buffer_count, count);\r\n    (void)real_constbuffer_array_get_buffer_count(value_buffers, &count);\r\n    ASSERT_ARE_EQUAL(uint32_t, value_buffer_count, count);\r\n\r\n    bool* found_blocks = (bool*)my_gballoc_malloc(block_count * sizeof(bool));\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        found_blocks[i] = false;\r\n    }\r\n    bool* found_values = (bool*)my_gballoc_malloc(value_count * sizeof(bool));\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        found_values[i] = false;\r\n    }\r\n\r\n    uint32_t buffer_index = 0;\r\n    for (uint32_t i = 0; i < block_count; ++i)\r\n    {\r\n        const CONSTBUFFER* block_id_buffer = real_constbuffer_array_get_buffer_content(block_buffers, buffer_index);\r\n        ++buffer_index;\r\n        ASSERT_ARE_EQUAL(size_t, sizeof(uint16_t) + 8, block_id_buffer->size);\r\n        uint16_t block_id_len;\r\n        real_read_uint16_t(block_id_buffer->buffer, &block_id_len);\r\n        ASSERT_ARE_EQUAL(uint16_t, 8, block_id_len);\r\n        const char* block_id = (const char*)(block_id_buffer->buffer + sizeof(uint16_t));\r\n\r\n        uint32_t j;\r\n        for (j = 0; j < block_count; ++j)\r\n        {\r\n            char block_id_to_check[255];\r\n            sprintf(block_id_to_check, \"block_%\" PRIu32, j + starting_block);\r\n            if (strcmp(block_id_to_check, block_id) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_blocks[j]);\r\n                found_blocks[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        ASSERT_ARE_NOT_EQUAL(uint32_t, block_count, j, \"block ID (%s) in serialized buffer was not expected\", block_id);\r\n\r\n        const CONSTBUFFER* block_buffer = real_constbuffer_array_get_buffer_content(block_buffers, buffer_index);\r\n        ++buffer_index;\r\n\r\n        ASSERT_ARE_EQUAL(size_t, sizeof(bsi_local_block_write_to_buffer_data), block_buffer->size);\r\n        ASSERT_IS_TRUE(0 == memcmp(bsi_local_block_write_to_buffer_data, block_buffer->buffer, sizeof(bsi_local_block_write_to_buffer_data)));\r\n    }\r\n\r\n    for (uint32_t j = 0; j < block_count; ++j)\r\n    {\r\n        ASSERT_IS_TRUE(found_blocks[j], \"expected block was not found in serialized form\");\r\n    }\r\n\r\n    buffer_index = 0;\r\n    for (uint32_t i = 0; i < value_count; ++i)\r\n    {\r\n        const CONSTBUFFER* key_buffer = real_constbuffer_array_get_buffer_content(value_buffers, buffer_index);\r\n        ++buffer_index;\r\n        ASSERT_ARE_EQUAL(size_t, sizeof(uint16_t) + 6, key_buffer->size);\r\n        uint16_t key_len;\r\n        real_read_uint16_t(key_buffer->buffer, &key_len);\r\n        ASSERT_ARE_EQUAL(uint16_t, 6, key_len);\r\n        const char* key = (const char*)(key_buffer->buffer + sizeof(uint16_t));\r\n\r\n        uint32_t j;\r\n        for (j = 0; j < value_count; ++j)\r\n        {\r\n            char key_to_check[255];\r\n            sprintf(key_to_check, \"key_%\" PRIu32, j + starting_key);\r\n            if (strcmp(key_to_check, key) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_values[j]);\r\n                found_values[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        ASSERT_ARE_NOT_EQUAL(uint32_t, value_count, j, \"Key (%s) in serialized buffer was not expected\", key);\r\n\r\n        const CONSTBUFFER* value_buffer = real_constbuffer_array_get_buffer_content(value_buffers, buffer_index);\r\n        ++buffer_index;\r\n\r\n        ASSERT_ARE_EQUAL(size_t, sizeof(bsi_local_value_write_to_buffer_data), value_buffer->size);\r\n        ASSERT_IS_TRUE(0 == memcmp(bsi_local_value_write_to_buffer_data, value_buffer->buffer, sizeof(bsi_local_value_write_to_buffer_data)));\r\n    }\r\n\r\n    for (uint32_t j = 0; j < value_count; ++j)\r\n    {\r\n        ASSERT_IS_TRUE(found_values[j], \"expected key value pair was not found in serialized form\");\r\n    }\r\n\r\n    my_gballoc_free(found_values);\r\n    my_gballoc_free(found_blocks);\r\n}\r\n\r\nBEGIN_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\r\n\r\nTEST_SUITE_INITIALIZE(suite_init)\r\n{\r\n    ASSERT_ARE_EQUAL(int, 0, real_gballoc_hl_init(NULL, NULL));\r\n    test_serialize_mutex = TEST_MUTEX_CREATE();\r\n    ASSERT_IS_NOT_NULL(test_serialize_mutex);\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, umock_c_init(on_umock_c_error), \"umock_c_init\");\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, umocktypes_stdint_register_types(), \"umocktypes_stdint_register_types\");\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, umocktypes_bool_register_types(), \"umocktypes_bool_register_types\");\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, umocktypes_charptr_register_types(), \"umocktypes_charptr_register_types\");\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, umocktypes_uuid_register_types(), \"umocktypes_uuid_register_types failed\");\r\n\r\n    REGISTER_CLDS_HAZARD_POINTERS_GLOBAL_MOCK_HOOKS();\r\n    REGISTER_CLDS_HASH_TABLE_GLOBAL_MOCK_HOOKS();\r\n    REGISTER_MEMORY_DATA_GLOBAL_MOCK_HOOK();\r\n    REGISTER_CONSTBUFFER_GLOBAL_MOCK_HOOK();\r\n    REGISTER_CONSTBUFFER_ARRAY_GLOBAL_MOCK_HOOK();\r\n    REGISTER_RC_STRING_GLOBAL_MOCK_HOOKS();\r\n    REGISTER_RC_STRING_ARRAY_GLOBAL_MOCK_HOOK();\r\n\r\n    REGISTER_GLOBAL_MOCK_RETURNS(UUID_generate, 0, MU_FAILURE);\r\n\r\n    REGISTER_GLOBAL_MOCK_HOOK(azure_messaging_metric_create, hook_azure_messaging_metric_create);\r\n    REGISTER_GLOBAL_MOCK_HOOK(azure_messaging_metric_destroy, hook_azure_messaging_metric_destroy);\r\n    REGISTER_GLOBAL_MOCK_HOOK(malloc, my_gballoc_malloc);\r\n    REGISTER_GLOBAL_MOCK_HOOK(free, my_gballoc_free);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(malloc, NULL);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(mocked_TlsSetValue, FALSE);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(clds_hazard_pointers_register_thread, NULL);\r\n    REGISTER_GLOBAL_MOCK_HOOK(hash_compute_hash, my_hash_compute_hash);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_create, my_bsi_local_block_create);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_create_from_buffer, my_bsi_local_block_create_from_buffer);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_get_incarnation_id, my_bsi_local_block_get_incarnation_id);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_start_append, my_bsi_local_block_start_append);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_abort_append, my_bsi_local_block_abort_append);\r\n    REGISTER_GLOBAL_MOCK_RETURN(bsi_local_block_start_append, BSI_LOCAL_BLOCK_APPEND_OK);\r\n    REGISTER_GLOBAL_MOCK_RETURNS(timer_create_new, test_timer, NULL);\r\n    REGISTER_GLOBAL_MOCK_RETURN(bsi_local_block_start_seal, BSI_LOCAL_BLOCK_SEAL_OK);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_append_get_offset, my_bsi_local_block_append_get_offset);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_block_write_to_buffer, my_bsi_local_block_write_to_buffer);\r\n    REGISTER_GLOBAL_MOCK_RETURN(bsi_local_value_create, test_bsi_local_value);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_value_get_incarnation_id, my_bsi_local_value_get_incarnation_id);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_value_get_etag, my_bsi_local_value_get_etag);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_value_create_from_buffer, my_bsi_local_value_create_from_buffer);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_value_get_operation_address, my_bsi_local_value_get_operation_address);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(bsi_local_value_get_operation_address, MU_FAILURE);\r\n    REGISTER_GLOBAL_MOCK_RETURNS(clds_hash_table_insert, CLDS_HASH_TABLE_INSERT_OK, CLDS_HASH_TABLE_INSERT_ERROR);\r\n    REGISTER_GLOBAL_MOCK_RETURNS(bsi_local_block_start_set_block_epoch, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_OK, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_ERROR);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bsi_local_value_write_to_buffer, my_bsi_local_value_write_to_buffer);\r\n    REGISTER_GLOBAL_MOCK_HOOK(bs_operation_address_compare, hook_bs_operation_address_compare);\r\n\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(CONSTBUFFER_Create, NULL);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(CONSTBUFFER_CreateWithMoveMemory, NULL);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(constbuffer_array_create_with_move_buffers, NULL);\r\n    REGISTER_GLOBAL_MOCK_FAIL_RETURN(rc_string_array_create, NULL);\r\n\r\n    REGISTER_GLOBAL_MOCK_HOOK(clds_hash_table_create, my_clds_hash_table_create);\r\n\r\n    REGISTER_TYPE(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_BLOCK_APPEND_RESULT, BSI_LOCAL_BLOCK_APPEND_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_BLOCK_SEAL_RESULT, BSI_LOCAL_BLOCK_SEAL_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT);\r\n    REGISTER_TYPE(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT, BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT);\r\n    REGISTER_TYPE(BS_OPERATION_ADDRESS_COMPARE_RESULT, BS_OPERATION_ADDRESS_COMPARE_RESULT);\r\n    REGISTER_TYPE(CLDS_HASH_TABLE_INSERT_RESULT, CLDS_HASH_TABLE_INSERT_RESULT);\r\n    REGISTER_TYPE(CLDS_HASH_TABLE_DELETE_RESULT, CLDS_HASH_TABLE_DELETE_RESULT);\r\n    REGISTER_TYPE(CLDS_HASH_TABLE_REMOVE_RESULT, CLDS_HASH_TABLE_REMOVE_RESULT);\r\n    REGISTER_TYPE(CLDS_HASH_TABLE_SET_VALUE_RESULT, CLDS_HASH_TABLE_SET_VALUE_RESULT);\r\n\r\n    REGISTER_UMOCK_ALIAS_TYPE(AZURE_MESSAGING_METRIC_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(AZURE_MESSAGING_METRIC_CONTEXT_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(TIMER_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(COMPUTE_HASH_FUNC, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(KEY_COMPARE_FUNC, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CLDS_HAZARD_POINTERS_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CLDS_HAZARD_POINTER_RECORD_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CLDS_HASH_TABLE_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(DWORD, unsigned long);\r\n    REGISTER_UMOCK_ALIAS_TYPE(HASH_TABLE_ITEM_CLEANUP_CB, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CLDS_HAZARD_POINTERS_THREAD_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(LPVOID, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BOOL, int);\r\n    REGISTER_UMOCK_ALIAS_TYPE(RECLAIM_FUNC, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(SORTED_LIST_GET_ITEM_KEY_CB, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(SORTED_LIST_KEY_COMPARE_CB, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSI_LOCAL_BLOCK_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSI_LOCAL_BLOCK_APPEND_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BS_OPERATION_ADDRESS_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(HASH_TABLE_SKIPPED_SEQ_NO_CB, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSI_LOCAL_BLOCK_SKIPPED_SEQ_NO_CB, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSI_LOCAL_VALUE_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSI_BUILDER_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BS_DISK_SPACE_TRACKER_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSOL_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(BSOL_IF, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CONSTBUFFER_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CONSTBUFFER_ARRAY_HANDLE, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(OFFLOAD_STORE_IF, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(RC_STRING_ARRAY*, void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(THANDLE(RC_STRING), void*);\r\n    REGISTER_UMOCK_ALIAS_TYPE(CONDITION_CHECK_CB, void*);\r\n}\r\n\r\nTEST_SUITE_CLEANUP(suite_cleanup)\r\n{\r\n    umock_c_deinit();\r\n\r\n    TEST_MUTEX_DESTROY(test_serialize_mutex);\r\n\r\n    real_gballoc_hl_deinit();\r\n}\r\n\r\nTEST_FUNCTION_INITIALIZE(method_init)\r\n{\r\n    if (TEST_MUTEX_ACQUIRE(test_serialize_mutex))\r\n    {\r\n        ASSERT_FAIL(\"Could not acquire test serialization mutex.\");\r\n    }\r\n\r\n    size_t metric_count = AZURE_MESSAGING_METRIC_COUNT(BSI_LOCAL_METRICS);\r\n    metrics = (AZURE_MESSAGING_METRIC_HANDLE*)malloc(sizeof(AZURE_MESSAGING_METRIC_HANDLE) * metric_count);\r\n    ASSERT_IS_NOT_NULL(metrics);\r\n    saved_hash_table_skipped_seq_no_index = 0;\r\n    test_append_sequence_number = 0;\r\n\r\n    g_bsi_local_block_get_incarnation_id_incarnation_id = &test_incarnation_id;\r\n    g_bsi_local_value_get_incarnation_id_incarnation_id = &test_incarnation_id;\r\n\r\n    test_operation_address_array_count = 0;\r\n\r\n    test_operation_address = create_test_bs_operation_address(5);\r\n    test_create_operation_address = create_test_bs_operation_address(6);\r\n    test_set_value_operation_address = create_test_bs_operation_address(7);\r\n    test_remove_value_operation_address = create_test_bs_operation_address(8);\r\n    test_set_block_epoch_operation_address = create_test_bs_operation_address(9);\r\n    test_previous_set_block_epoch_address = create_test_bs_operation_address(10);\r\n\r\n    (void)interlocked_exchange_64(&test_sequence_number, -1);\r\n\r\n    umock_c_reset_all_calls();\r\n    umock_c_negative_tests_init();\r\n}\r\n\r\nTEST_FUNCTION_CLEANUP(method_cleanup)\r\n{\r\n    umock_c_negative_tests_deinit();\r\n    free(metrics);\r\n\r\n    hook_bs_operation_address_dec_ref(test_operation_address);\r\n    hook_bs_operation_address_dec_ref(test_create_operation_address);\r\n    hook_bs_operation_address_dec_ref(test_set_value_operation_address);\r\n    hook_bs_operation_address_dec_ref(test_remove_value_operation_address);\r\n    hook_bs_operation_address_dec_ref(test_set_block_epoch_operation_address);\r\n    hook_bs_operation_address_dec_ref(test_previous_set_block_epoch_address);\r\n\r\n    for (uint32_t i = 0; i < test_operation_address_array_count; ++i)\r\n    {\r\n        hook_bs_operation_address_dec_ref(test_operation_address_array[i]);\r\n        test_operation_address_array[i] = NULL;\r\n    }\r\n    test_operation_address_array_count = 0;\r\n\r\n    TEST_MUTEX_RELEASE(test_serialize_mutex);\r\n}\r\n\r\nstatic void setup_bsi_local_destroy_metrics_expectations(void)\r\n{\r\n    size_t metric_count = AZURE_MESSAGING_METRIC_COUNT(BSI_LOCAL_METRICS);\r\n    for (size_t i = 0; i < metric_count; i++)\r\n    {\r\n        STRICT_EXPECTED_CALL(azure_messaging_metric_destroy(metrics[i]));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n}\r\n\r\n/* bsi_local_create */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_038: [ If sequence_number is NULL then bsi_local_create shall fail and return NULL. ]*/\r\nTEST_FUNCTION(bsi_local_create_with_NULL_sequence_number_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n\r\n    // act\r\n    bsi_local = bsi_local_create(test_metric_context, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NULL(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_001: [ bsi_local_create shall allocate memory for a new index object and on success return a non-NULL handle to it. ]*/\r\n/* Tests_SRS_BSI_LOCAL_03_004: [ If metric_context is not NULL, bsi_local_create shall call azure_messaging_metric_create for each value in the enum bsi_metrics. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_002: [ bsi_local_create shall allocate a thread local storage slot by calling TlsAlloc. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_003: [ bsi_local_create shall create a CLDS hazard pointers instance to be used by the hash table where the blocks are stored. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_004: [ bsi_local_create shall create a CLDS hash table for the block index by calling clds_hash_table_create and pass to it the index_block_id_key_hash and index_block_id_key_compare for key hashing and key compare. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_143: [ bsi_local_create shall create a CLDS hash table for the key-value pairs index by calling clds_hash_table_create and pass to it the index_value_key_hash and index_value_key_compare for key hashing and key compare. ]*/\r\n/* Tests_SRS_BSI_LOCAL_03_001: [ bsi_local_create shall call timer_create_new. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_087: [ The initial bucket count for the hash tables shall be 2^10. ]*/\r\nTEST_FUNCTION(bsi_local_create_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc());\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_create_new());\r\n\r\n    // act\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(bsi_local);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_03_003: [ metric_context can be NULL. ]*/\r\nTEST_FUNCTION(bsi_local_create_succeeds_metric_context_can_be_NULL)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc());\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_create_new());\r\n\r\n    // act\r\n    bsi_local = bsi_local_create(NULL, &test_sequence_number);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(bsi_local);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_005: [ If any error occurs, bsi_local_create shall fail and return NULL. ]*/\r\nTEST_FUNCTION(when_underlying_calls_fail_bsi_local_create_fails)\r\n{\r\n    // arrange\r\n    size_t i;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)).SetFailReturn(NULL);\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc()).SetFailReturn(TLS_OUT_OF_INDEXES);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create()).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(timer_create_new());\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        saved_hash_table_skipped_seq_no_index = 0;\r\n\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n            // assert\r\n            ASSERT_IS_NULL(bsi_local, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n}\r\n\r\n/* bsi_local_destroy */\r\n\r\n/* Tests_SRS_BSI_LOCAL_03_002: [ bsi_local_destroy shall call timer_destroy ]*/\r\n/* Tests_SRS_BSI_LOCAL_03_005: [ bsi_local_destroy shall destroy all metrics created in bsi_local_create by calling azure_messaging_metric_destroy. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_006: [ bsi_local_destroy shall free the memory associated with the block storage index object. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_144: [ bsi_local_destroy shall destroy the hash table used for the key-value pairs index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_008: [ bsi_local_destroy shall destroy the hash table used for the block index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_009: [ bsi_local_destroy shall destroy the CLDS hazard pointers instance created in bsi_local_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_010: [ bsi_local_destroy shall free the thread local storage slot allocated in bsi_local_create. ]*/\r\nTEST_FUNCTION(bsi_local_destroy_frees_the_resources)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&kvp_hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    setup_bsi_local_destroy_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(timer_destroy(test_timer));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_destroy(kvp_hash_table));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_destroy(hash_table));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_destroy(clds_hazard_pointers));\r\n    STRICT_EXPECTED_CALL(mocked_TlsFree(tls_slot));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    bsi_local_destroy(bsi_local);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_007: [ If bsi_local is NULL, bsi_local_destroy shall return. ]*/\r\nTEST_FUNCTION(bsi_local_destroy_with_NULL_handle_returns)\r\n{\r\n    // arrange\r\n\r\n    // act\r\n    bsi_local_destroy(NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* bsi_local_load_from_buffers */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_059: [ If bsi_local is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_bsi_local_fails)\r\n{\r\n    // arrange\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(NULL, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_060: [ If bsi_builder is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_bsi_builder_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, NULL, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_145: [ If bs_disk_space_tracker is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_bs_disk_space_tracker_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, NULL, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_146: [ If bsol is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_bsol_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, NULL, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_061: [ If bsol_if is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_bsol_if_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, NULL, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_147: [ If offload_store is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_offload_store_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, NULL, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_153: [ If local_block_buffers is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_local_block_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, NULL, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_154: [ If local_value_buffers is NULL then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_ARGS. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_NULL_local_value_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_ARGS, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_155: [ If the buffer count in local_block_buffers is not divisible by 2 then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_odd_count_block_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers_bad = real_constbuffer_array_create_from_buffer_index_and_count(local_block_buffers, 0, 5);\r\n    ASSERT_IS_NOT_NULL(local_block_buffers_bad);\r\n\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_block_buffers_bad, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_value_buffers, IGNORED_ARG));\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_156: [ If the buffer count in local_value_buffers is not divisible by 2 then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_odd_count_value_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = real_constbuffer_array_create_from_buffer_index_and_count(local_value_buffers, 0, 5);\r\n    ASSERT_IS_NOT_NULL(local_value_buffers_bad);\r\n\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_block_buffers, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_count(local_value_buffers_bad, IGNORED_ARG));\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_157: [ bsi_local_load_from_buffers shall get the block_count as the buffer count in local_block_buffers divided by 2. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_158: [ bsi_local_load_from_buffers shall get the value_count as the buffer count in local_value_buffers divided by 2. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_141: [ bsi_local_load_from_buffers shall allocate an array of block_count size for all read blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_142: [ bsi_local_load_from_buffers shall allocate an array of value_count size for all read values. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_069: [ bsi_local_load_from_buffers shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_070: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_071: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_074: [ If the block_id_buffer is too small to read the required fields then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_block_id_buffer_too_small_for_fixed_fields_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // Modify the first block ID buffer\r\n    unsigned char block_id_bad[sizeof(uint16_t)];\r\n    (void)memset(block_id_bad, 0, sizeof(block_id_bad));\r\n    CONSTBUFFER_HANDLE block_id_bad_buffer = real_CONSTBUFFER_Create(block_id_bad, sizeof(block_id_bad) - 1);\r\n    ASSERT_IS_NOT_NULL(block_id_bad_buffer);\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers_bad = test_replace_one_buffer_in_array(local_block_buffers, 0, block_id_bad_buffer);\r\n    real_CONSTBUFFER_DecRef(block_id_bad_buffer);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // block_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers_bad, 0));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_157: [ bsi_local_load_from_buffers shall get the block_count as the buffer count in local_block_buffers divided by 2. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_158: [ bsi_local_load_from_buffers shall get the value_count as the buffer count in local_value_buffers divided by 2. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_141: [ bsi_local_load_from_buffers shall allocate an array of block_count size for all read blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_142: [ bsi_local_load_from_buffers shall allocate an array of value_count size for all read values. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_069: [ bsi_local_load_from_buffers shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_070: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_071: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_074: [ If the block_id_buffer is too small to read the required fields then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_block_id_buffer_too_small_for_fixed_fields_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    // Modify the third block ID buffer\r\n    unsigned char block_id_bad[sizeof(uint16_t)];\r\n    (void)memset(block_id_bad, 0, sizeof(block_id_bad));\r\n    CONSTBUFFER_HANDLE block_id_bad_buffer = real_CONSTBUFFER_Create(block_id_bad, sizeof(block_id_bad) - 1);\r\n    ASSERT_IS_NOT_NULL(block_id_bad_buffer);\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers_bad = test_replace_one_buffer_in_array(local_block_buffers, 4, block_id_bad_buffer);\r\n    real_CONSTBUFFER_DecRef(block_id_bad_buffer);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // block_1\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers_bad, 0, 1, &(hash_table_item[0]));\r\n\r\n    // block_2\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers_bad, 2, 3, &(hash_table_item[1]));\r\n\r\n    // block_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers_bad, 4));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_076: [ If the block_id_buffer is too small to read the block_id_length then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_block_id_buffer_too_small_for_block_id_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // Modify the first block ID buffer\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers_bad = test_shrink_one_buffer_in_array(local_block_buffers, 0);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // block_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers_bad, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_076: [ If the block_id_buffer is too small to read the block_id_length then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_block_id_buffer_too_small_for_block_id_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    // Modify the third block ID buffer\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers_bad = test_shrink_one_buffer_in_array(local_block_buffers, 4);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // block_1\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers_bad, 0, 1, &(hash_table_item[0]));\r\n\r\n    // block_2\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers_bad, 2, 3, &(hash_table_item[1]));\r\n\r\n    // block_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers_bad, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers_bad, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_080: [ If bsi_local_block_create_from_buffer returns BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OUT_OF_RANGE then bsi_local_load_from_buffers shall skip this block. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_all_out_of_range_succeeds_does_not_add_blocks)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 0, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, i * 2));\r\n        STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 1 + i * 2));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n            .SetReturn(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n    }\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_081: [ If bsi_local_block_create_from_buffer returns BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_DATA then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_invalid_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // block_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_DATA);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_081: [ If bsi_local_block_create_from_buffer returns BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_DATA then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_invalid_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // block_1\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, 0, 1, &(hash_table_item[0]));\r\n\r\n    // block_2\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, 2, 3, &(hash_table_item[1]));\r\n\r\n    // block_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_DATA);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nstatic void test_case_bsi_local_load_from_buffers_with_3_blocks_first_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT create_result)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // block_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n        .SetReturn(create_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_fails_with_ERROR_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_first_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_ERROR);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_fails_with_INVALID_DATA_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_first_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_ARGS);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_fails_with_INVALID_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_first_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT_INVALID);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_first_fails_with_unknown_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_first_fails((BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT)0xff);\r\n}\r\n\r\nstatic void test_case_bsi_local_load_from_buffers_with_3_blocks_third_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT create_result)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // block_1\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, 0, 1, &(hash_table_item[0]));\r\n\r\n    // block_2\r\n    setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, 2, 3, &(hash_table_item[1]));\r\n\r\n    // block_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n        .SetReturn(create_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_fails_with_ERROR_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_third_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_ERROR);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_fails_with_INVALID_DATA_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_third_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_INVALID_ARGS);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_fails_with_INVALID_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_third_fails(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT_INVALID);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_082: [ If bsi_local_block_create_from_buffer returns anything else besides BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_third_fails_with_unknown_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_third_fails((BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_RESULT)0xff);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_083: [ bsi_local_load_from_buffers shall create a pending block item to be inserted in the hash table and store it in the allocated array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_084: [ bsi_local_load_from_buffers shall set the block state to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_143: [ For each of the block_count items in the array: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_152: [ bsi_local_load_from_buffers shall call bsi_local_block_is_block_seal_started to get the is_sealed. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_148: [ bsi_local_load_from_buffers shall call bsi_disk_space_reserver_get_additional_space_required_for_allocate with is_sealed to get the long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_149: [ bsi_local_load_from_buffers shall call bs_disk_space_tracker_force_reserve with long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_085: [ bsi_local_load_from_buffers shall insert the new block item in the hash table by using clds_hash_table_insert. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_086: [ bsi_local_load_from_buffers shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_101: [ bsi_local_load_from_buffers shall succeed and return BSI_LOCAL_LOAD_INDEX_OK. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 0, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n    const char* block_id[3] = {\r\n        \"block_0\",\r\n        \"block_1\",\r\n        \"block_2\"\r\n    };\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_block(hash_table, block_id[i], i == 0, &(hash_table_item[i]), i, i + 1);\r\n    }\r\n\r\n    // cleanup\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_BLOCK_HANDLE block;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_OK, bsi_local_find_block(bsi_local, block_id[i], &block));\r\n        ASSERT_IS_NOT_NULL(block);\r\n        bsi_local_block_dec_ref(block);\r\n    }\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_089: [ If the key_buffer is too small to read the required fields then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_key_buffer_too_small_for_fixed_fields_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // Modify the first key buffer\r\n    unsigned char key_bad[sizeof(uint16_t)];\r\n    (void)memset(key_bad, 0, sizeof(key_bad));\r\n    CONSTBUFFER_HANDLE key_bad_buffer = real_CONSTBUFFER_Create(key_bad, sizeof(key_bad) - 1);\r\n    ASSERT_IS_NOT_NULL(key_bad_buffer);\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_replace_one_buffer_in_array(local_value_buffers, 0, key_bad_buffer);\r\n    real_CONSTBUFFER_DecRef(key_bad_buffer);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // key_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 0));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_089: [ If the key_buffer is too small to read the required fields then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_key_buffer_too_small_for_fixed_fields_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    // Modify the third key buffer\r\n    unsigned char key_bad[sizeof(uint16_t)];\r\n    (void)memset(key_bad, 0, sizeof(key_bad));\r\n    CONSTBUFFER_HANDLE key_bad_buffer = real_CONSTBUFFER_Create(key_bad, sizeof(key_bad) - 1);\r\n    ASSERT_IS_NOT_NULL(key_bad_buffer);\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_replace_one_buffer_in_array(local_value_buffers, 4, key_bad_buffer);\r\n    real_CONSTBUFFER_DecRef(key_bad_buffer);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // key_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 0, 1, &(hash_table_item[0]));\r\n\r\n    // key_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 2, 3, &(hash_table_item[1]));\r\n\r\n    // key_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 4));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_089: [ If the key_buffer is too small to read the required fields then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_key_buffer_too_small_for_fixed_fields_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n\r\n    // Modify the third key buffer\r\n    unsigned char key_bad[sizeof(uint16_t)];\r\n    (void)memset(key_bad, 0, sizeof(key_bad));\r\n    CONSTBUFFER_HANDLE key_bad_buffer = real_CONSTBUFFER_Create(key_bad, sizeof(key_bad) - 1);\r\n    ASSERT_IS_NOT_NULL(key_bad_buffer);\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_replace_one_buffer_in_array(local_value_buffers, 4, key_bad_buffer);\r\n    real_CONSTBUFFER_DecRef(key_bad_buffer);\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    // key_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 0, 1, &(hash_table_item[3]));\r\n\r\n    // key_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 2, 3, &(hash_table_item[4]));\r\n\r\n    // key_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 4));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[3]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[4]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_091: [ If the key_buffer is too small to read the key_length then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_key_buffer_too_small_for_key_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    // Modify the first key buffer\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_shrink_one_buffer_in_array(local_value_buffers, 0);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // key_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_091: [ If the key_buffer is too small to read the key_length then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_key_buffer_too_small_for_key_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    // Modify the third key buffer\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_shrink_one_buffer_in_array(local_value_buffers, 4);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // key_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 0, 1, &(hash_table_item[0]));\r\n\r\n    // key_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 2, 3, &(hash_table_item[1]));\r\n\r\n    // key_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_091: [ If the key_buffer is too small to read the key_length then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_key_buffer_too_small_for_key_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n\r\n    // Modify the third key buffer\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers_bad = test_shrink_one_buffer_in_array(local_value_buffers, 4);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers_bad);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    // key_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 0, 1, &(hash_table_item[3]));\r\n\r\n    // key_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers_bad, 2, 3, &(hash_table_item[4]));\r\n\r\n    // key_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers_bad, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[3]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[4]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers_bad);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_value_buffers_bad);\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_095: [ If bsi_local_value_create_from_buffer returns BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OUT_OF_RANGE then bsi_local_load_from_buffers shall skip this key-value pair. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_all_out_of_range_succeeds_does_not_add_values)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, i * 2));\r\n        STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 1 + i * 2));\r\n        STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n            .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n    }\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_080: [ If bsi_local_block_create_from_buffer returns BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OUT_OF_RANGE then bsi_local_load_from_buffers shall skip this block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_095: [ If bsi_local_value_create_from_buffer returns BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OUT_OF_RANGE then bsi_local_load_from_buffers shall skip this key-value pair. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_all_out_of_range_succeeds_does_not_add_anything)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, i * 2));\r\n        STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 1 + i * 2));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n            .SetReturn(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, i * 2));\r\n        STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n        STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 1 + i * 2));\r\n        STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n            .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n    }\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_096: [ If bsi_local_value_create_from_buffer returns BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_invalid_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // value_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 1));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_096: [ If bsi_local_value_create_from_buffer returns BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_invalid_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // value_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 0, 1, &(hash_table_item[0]));\r\n\r\n    // value_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 2, 3, &(hash_table_item[1]));\r\n\r\n    // value_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_096: [ If bsi_local_value_create_from_buffer returns BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_INVALID_DATA. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_invalid_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    // value_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 0, 1, &(hash_table_item[3]));\r\n\r\n    // value_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 2, 3, &(hash_table_item[4]));\r\n\r\n    // value_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_DATA);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[3]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[4]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_INVALID_DATA, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nstatic void test_case_bsi_local_load_from_buffers_with_3_values_first_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT create_result)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // value_1\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 0));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 1));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(create_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_fails_with_ERROR_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_first_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_ERROR);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_fails_with_INVALID_ARGS_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_first_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_ARGS);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_fails_with_INVALID_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_first_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT_INVALID);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_first_fails_with_unknown_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_first_fails((BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT)0xff);\r\n}\r\n\r\nstatic void test_case_bsi_local_load_from_buffers_with_3_values_third_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT create_result)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    // value_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 0, 1, &(hash_table_item[0]));\r\n\r\n    // value_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 2, 3, &(hash_table_item[1]));\r\n\r\n    // value_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(create_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[0]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[1]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_fails_with_ERROR_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_third_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_ERROR);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_fails_with_INVALID_ARGS_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_third_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_ARGS);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_fails_with_INVALID_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_third_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT_INVALID);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_third_fails_with_unknown_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_values_third_fails((BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT)0xff);\r\n}\r\n\r\nstatic void test_case_bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT create_result)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    // value_1\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 0, 1, &(hash_table_item[3]));\r\n\r\n    // value_2\r\n    setup_expectation_load_from_buffer_read_value(local_value_buffers, 2, 3, &(hash_table_item[4]));\r\n\r\n    // value_3\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 4));\r\n    STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n    STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 5));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n        .SetReturn(create_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n\r\n    // cleanup\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[3]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&(hash_table_item[4]));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n        STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n        STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(test_bsi_local_block));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result);\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails_with_ERROR_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_ERROR);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails_with_INVALID_ARGS_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_INVALID_ARGS);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails_with_INVALID_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT_INVALID);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_097: [ If bsi_local_value_create_from_buffer returns anything else besides BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OK then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails_with_unknown_fails)\r\n{\r\n    test_case_bsi_local_load_from_buffers_with_3_blocks_and_3_values_third_value_fails((BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_RESULT)0xff);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_098: [ bsi_local_load_from_buffers shall create a structure to hold the key-value pair and store it in the allocated array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_195: [ bsi_local_load_from_buffers shall set the key-value pair state to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_144: [ For each of the value_count items in the array: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_150: [ bsi_local_load_from_buffers shall call bsi_disk_space_reserver_get_additional_space_required_for_set_value to get the long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_151: [ bsi_local_load_from_buffers shall call bs_disk_space_tracker_force_reserve with long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_099: [ bsi_local_load_from_buffers shall insert the new key-value pair item in the hash table by using clds_hash_table_insert. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_100: [ bsi_local_load_from_buffers shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_101: [ bsi_local_load_from_buffers shall succeed and return BSI_LOCAL_LOAD_INDEX_OK. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_values_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(0, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[3];\r\n    const char* key[3] = {\r\n        \"key_0\",\r\n        \"key_1\",\r\n        \"key_2\"\r\n    };\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_value(local_value_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_value(kvp_hash_table, key[i], &(hash_table_item[i]), i, i + 1);\r\n    }\r\n\r\n    // cleanup\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_VALUE_HANDLE value;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, bsi_local_get_value(bsi_local, key[i], &value));\r\n        ASSERT_IS_NOT_NULL(value);\r\n        bsi_local_value_dec_ref(value);\r\n    }\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n/* Tests_SRS_BSI_LOCAL_42_072: [ For each buffer up to block_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_073: [ bsi_local_load_from_buffers shall read the next buffer as the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_075: [ bsi_local_load_from_buffers shall read the block_id_length field from the block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_077: [ bsi_local_load_from_buffers shall read the block_id field from the block_id_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_078: [ bsi_local_load_from_buffers shall read the next buffer as the block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_079: [ bsi_local_load_from_buffers shall call bsi_local_block_create_from_buffer with the bsi_builder, bsol_if, and block_content_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_083: [ bsi_local_load_from_buffers shall create a pending block item to be inserted in the hash table and store it in the allocated array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_084: [ bsi_local_load_from_buffers shall set the block state to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_143: [ For each of the block_count items in the array: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_152: [ bsi_local_load_from_buffers shall call bsi_local_block_is_block_seal_started to get the is_sealed. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_148: [ bsi_local_load_from_buffers shall call bsi_disk_space_reserver_get_additional_space_required_for_allocate with is_sealed to get the long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_149: [ bsi_local_load_from_buffers shall call bs_disk_space_tracker_force_reserve with long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_085: [ bsi_local_load_from_buffers shall insert the new block item in the hash table by using clds_hash_table_insert. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_086: [ bsi_local_load_from_buffers shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_101: [ bsi_local_load_from_buffers shall succeed and return BSI_LOCAL_LOAD_INDEX_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_087: [ For each buffer up to value_count: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_088: [ bsi_local_load_from_buffers shall read the next buffer as the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_090: [ bsi_local_load_from_buffers shall read the key_length field from the key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_092: [ bsi_local_load_from_buffers shall read the key field from the key_buffer and clone it into a new buffer to be used as the key of the item being added to the hash table. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_093: [ bsi_local_load_from_buffers shall read the next buffer as the value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_094: [ bsi_local_load_from_buffers shall call bsi_local_value_create_from_buffer with the bsi_builder, bsol_if, and value_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_098: [ bsi_local_load_from_buffers shall create a structure to hold the key-value pair and store it in the allocated array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_195: [ bsi_local_load_from_buffers shall set the key-value pair state to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_144: [ For each of the value_count items in the array: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_150: [ bsi_local_load_from_buffers shall call bsi_disk_space_reserver_get_additional_space_required_for_set_value to get the long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_151: [ bsi_local_load_from_buffers shall call bs_disk_space_tracker_force_reserve with long_term_reserved_space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_099: [ bsi_local_load_from_buffers shall insert the new key-value pair item in the hash table by using clds_hash_table_insert. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_100: [ bsi_local_load_from_buffers shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_101: [ bsi_local_load_from_buffers shall succeed and return BSI_LOCAL_LOAD_INDEX_OK. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n    const char* block_id[3] = {\r\n        \"block_0\",\r\n        \"block_1\",\r\n        \"block_2\"\r\n    };\r\n    const char* key[3] = {\r\n        \"key_0\",\r\n        \"key_1\",\r\n        \"key_2\"\r\n    };\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_value(local_value_buffers, i * 2, 1 + i * 2, &(hash_table_item[3 + i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_block(hash_table, block_id[i], i == 1, &(hash_table_item[i]), i, i + 1);\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_value(kvp_hash_table, key[i], &(hash_table_item[3 + i]), 3 + i, i + 1);\r\n    }\r\n\r\n    // cleanup\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[3 + i]));\r\n    }\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_BLOCK_HANDLE block;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_OK, bsi_local_find_block(bsi_local, block_id[i], &block));\r\n        ASSERT_IS_NOT_NULL(block);\r\n        bsi_local_block_dec_ref(block);\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_VALUE_HANDLE value;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, bsi_local_get_value(bsi_local, key[i], &value));\r\n        ASSERT_IS_NOT_NULL(value);\r\n        bsi_local_value_dec_ref(value);\r\n    }\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_101: [ bsi_local_load_from_buffers shall succeed and return BSI_LOCAL_LOAD_INDEX_OK. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_but_second_of_each_is_out_of_bounds_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n    const char* block_id[3] = {\r\n        \"block_0\",\r\n        \"block_1\",\r\n        \"block_2\"\r\n    };\r\n    const char* key[3] = {\r\n        \"key_0\",\r\n        \"key_1\",\r\n        \"key_2\"\r\n    };\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i == 1)\r\n        {\r\n            STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, i * 2));\r\n            STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n            STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n            STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_block_buffers, 1 + i * 2));\r\n            STRICT_EXPECTED_CALL(bsi_local_block_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG, tls_slot, IGNORED_ARG, IGNORED_ARG, bsi_local, IGNORED_ARG))\r\n                .SetReturn(BSI_LOCAL_BLOCK_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n            STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block ID\r\n        }\r\n        else\r\n        {\r\n            setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i == 1)\r\n        {\r\n            STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, i * 2));\r\n            STRICT_EXPECTED_CALL(read_uint16_t(IGNORED_ARG, IGNORED_ARG));\r\n            STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)); // sprintf\r\n            STRICT_EXPECTED_CALL(constbuffer_array_get_buffer_content(local_value_buffers, 1 + i * 2));\r\n            STRICT_EXPECTED_CALL(bsi_local_value_create_from_buffer(test_bsi_builder, test_bsol_if, IGNORED_ARG, 0, IGNORED_ARG))\r\n                .SetReturn(BSI_LOCAL_VALUE_CREATE_FROM_BUFFER_OUT_OF_RANGE);\r\n            STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // key\r\n        }\r\n        else\r\n        {\r\n            setup_expectation_load_from_buffer_read_value(local_value_buffers, i * 2, 1 + i * 2, &(hash_table_item[3 + i]));\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i != 1)\r\n        {\r\n            setup_expectation_load_from_buffer_write_block(hash_table, block_id[i], i == 0, &(hash_table_item[i]), i - (i > 1 ? 1 : 0), i + 1 - (i > 1 ? 1 : 0));\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i != 1)\r\n        {\r\n            setup_expectation_load_from_buffer_write_value(kvp_hash_table, key[i], &(hash_table_item[3 + i]), 2 + i - (i > 1 ? 1 : 0), i + 1 - (i > 1 ? 1 : 0));\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i != 1)\r\n        {\r\n            STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n                .ValidateArgumentValue_item(&(hash_table_item[3 + i]));\r\n        }\r\n    }\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        if (i != 1)\r\n        {\r\n            STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n                .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n        }\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    // act\r\n    BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_OK, result);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_BLOCK_HANDLE block;\r\n        if (i == 1)\r\n        {\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_NOT_FOUND, bsi_local_find_block(bsi_local, block_id[i], &block));\r\n        }\r\n        else\r\n        {\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_OK, bsi_local_find_block(bsi_local, block_id[i], &block));\r\n            ASSERT_IS_NOT_NULL(block);\r\n            bsi_local_block_dec_ref(block);\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_VALUE_HANDLE value;\r\n        if (i == 1)\r\n        {\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_NOT_FOUND, bsi_local_get_value(bsi_local, key[i], &value));\r\n        }\r\n        else\r\n        {\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, bsi_local_get_value(bsi_local, key[i], &value));\r\n            ASSERT_IS_NOT_NULL(value);\r\n            bsi_local_value_dec_ref(value);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_102: [ If there are any other errors then bsi_local_load_from_buffers shall fail and return BSI_LOCAL_LOAD_INDEX_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_load_from_buffers_with_3_blocks_and_3_values_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000));\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE local_block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE local_value_buffers;\r\n    test_create_buffers_to_load(3, 3, &local_block_buffers, &local_value_buffers);\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item[6];\r\n    const char* block_id[3] = {\r\n        \"block_0\",\r\n        \"block_1\",\r\n        \"block_2\"\r\n    };\r\n    const char* key[3] = {\r\n        \"key_0\",\r\n        \"key_1\",\r\n        \"key_2\"\r\n    };\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    ignore_expected_calls();\r\n\r\n    setup_expectation_load_from_buffer_header(tls_slot, local_block_buffers, local_value_buffers);\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_block(tls_slot, local_block_buffers, i * 2, 1 + i * 2, &(hash_table_item[i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_read_value(local_value_buffers, i * 2, 1 + i * 2, &(hash_table_item[3 + i]));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_block(hash_table, block_id[i], i == 1, &(hash_table_item[i]), i, i + 1);\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        setup_expectation_load_from_buffer_write_value(kvp_hash_table, key[i], &(hash_table_item[3 + i]), 3 + i, i + 1);\r\n    }\r\n\r\n    // cleanup\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[3 + i]));\r\n    }\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n            .ValidateArgumentValue_item(&(hash_table_item[i]));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // value array\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // block array\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            BSI_LOCAL_LOAD_INDEX_RESULT result = bsi_local_load_from_buffers(bsi_local, test_bsi_builder, test_disk_space_tracker, test_bsol, test_bsol_if, test_offload_store, local_block_buffers, local_value_buffers);\r\n\r\n            // assert\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_LOAD_INDEX_RESULT, BSI_LOCAL_LOAD_INDEX_ERROR, result, \"On failed call %zu\", i);\r\n\r\n            // reset\r\n            TlsSetValue(tls_slot, NULL);\r\n            (void)interlocked_exchange_64(&test_sequence_number, -1);\r\n        }\r\n    }\r\n\r\n    // After all the failures, the blocks should not be found\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_BLOCK_HANDLE block;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_NOT_FOUND, bsi_local_find_block(bsi_local, block_id[i], &block));\r\n    }\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        BSI_LOCAL_VALUE_HANDLE value;\r\n        ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_NOT_FOUND, bsi_local_get_value(bsi_local, key[i], &value));\r\n    }\r\n\r\n    // cleanup\r\n    real_constbuffer_array_dec_ref(local_block_buffers);\r\n    real_constbuffer_array_dec_ref(local_value_buffers);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_create_block */\r\n\r\nstatic void expect_bsi_local_create_block(\r\n    const char* block_id,\r\n    UUID_T incarnation_id,\r\n    DWORD tls_slot,\r\n    CLDS_HASH_TABLE_HANDLE hash_table,\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers,\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE* clds_hazard_pointers_thread,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item,\r\n    bool insert_fails_already_exists_then_succeeds,\r\n    bool creates_hazard_pointers,\r\n    uint64_t block_count)\r\n{\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n\r\n    if (creates_hazard_pointers)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n            .CaptureReturn(clds_hazard_pointers_thread);\r\n        STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n            .ValidateArgumentValue_lpTlsValue((LPVOID*)clds_hazard_pointers_thread);\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, incarnation_id, clds_hazard_pointers, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table_item);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(hash_table_item);\r\n\r\n    if (insert_fails_already_exists_then_succeeds)\r\n    {\r\n        // Pretend like the first one was removed between calls of insert and find\r\n        STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, (void*)block_id, IGNORED_ARG, IGNORED_ARG))\r\n            .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n            .ValidateArgumentValue_value(hash_table_item)\r\n            .SetReturn(CLDS_HASH_TABLE_INSERT_KEY_ALREADY_EXISTS);\r\n        STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, (void*)block_id))\r\n            .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, (void*)block_id, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(hash_table_item);\r\n\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], block_count))\r\n        .CallCannotFail();\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_011: [ On success bsi_local_create_block shall return BSI_LOCAL_CREATE_BLOCK_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_070: [ bsi_local_create_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_071: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_072: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_015: [ bsi_local_create_block shall create a pending block item to be inserted in the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_091: [ bsi_local_create_block shall create a new block object used to track appends by calling bsi_local_block_create and passing block_size and incarnation_id as arguments. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_016: [ bsi_local_create_block shall clone the block_id by using mallocAndStrcpy_s and use the cloned value as the key of the item being added to the hashtable. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_018: [ bsi_local_create_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_019: [ bsi_local_create_block shall insert the new block item in the hash table by using clds_hash_table_insert. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_053: [ bsi_local_create_block shall log the metric BSI_LOCAL_BLOCK_COUNT with the total count of blocks in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_021: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_089: [ bsi_local_create_block shall increment the reference count of the block. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    // act\r\n    result =  bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_070: [ bsi_local_create_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\nTEST_FUNCTION(second_bsi_local_create_block_does_not_create_a_hazard_pointers_thread)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action));\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_abort_action(index_update_action));\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_create_block(\"block2\", test_incarnation_id2, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        false /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block2\", test_incarnation_id2, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_011: [ On success bsi_local_create_block shall return BSI_LOCAL_CREATE_BLOCK_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_070: [ bsi_local_create_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_071: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_072: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_015: [ bsi_local_create_block shall create a pending block item to be inserted in the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_091: [ bsi_local_create_block shall create a new block object used to track appends by calling bsi_local_block_create and passing block_size and incarnation_id as arguments. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_016: [ bsi_local_create_block shall clone the block_id by using mallocAndStrcpy_s and use the cloned value as the key of the item being added to the hashtable. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_018: [ bsi_local_create_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_019: [ bsi_local_create_block shall insert the new block item in the hash table by using clds_hash_table_insert. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_053: [ bsi_local_create_block shall log the metric BSI_LOCAL_BLOCK_COUNT with the total count of blocks in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_021: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_089: [ bsi_local_create_block shall increment the reference count of the block. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_with_2_different_blocks_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result_1;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_1;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_2;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, &test_sequence_number, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_1,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n    expect_bsi_local_create_block(\"block2\", test_incarnation_id2, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_2,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        false /*creates_hazard_pointers*/,\r\n        2);\r\n\r\n    // act\r\n    result_1 = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1);\r\n    result_2 = bsi_local_create_block(bsi_local, \"block2\", test_incarnation_id2, 4 MB, &index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, result_1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, result_2);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_1);\r\n    (void)bsi_local_abort_action(index_update_action_2);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_012: [ If bsi_local is NULL, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n\r\n    // act\r\n    result = bsi_local_create_block(NULL, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_013: [ If block_id is NULL, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, NULL, test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_001: [ If incarnation_id is NULL then bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_with_NULL_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", NULL, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_014: [ If index_update_action is NULL, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_create_block_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_022: [ If any error occurs, then bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(when_underlying_calls_fail_bsi_local_create_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    size_t i;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block_x\", test_incarnation_id2, 4 MB, &index_update_action));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_abort_action(index_update_action));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer)).CallCannotFail();\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG)).CallCannotFail();\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, test_incarnation_id, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG)).SetFailReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG)).SetFailReturn(1);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).SetFailReturn(CLDS_HASH_TABLE_INSERT_ERROR);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n            // assert\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_022: [ If any error occurs, then bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(when_creating_the_hazard_pointers_thread_fails_bsi_local_create_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_022: [ If any error occurs, then bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_thread_local_hazard_pointers_thread_fails_bsi_local_create_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_035: [ For create block actions, the state of the block shall changed from CREATED to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_027: [ If the block already exists in the hash table then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_028: [ bsi_local_create_block shall call clds_hash_table_find to get the existing block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_025: [ If the state of the found block is not CREATED, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_ALREADY_EXISTS. ]*/\r\nTEST_FUNCTION(when_the_block_already_exists_bsi_local_create_block_returns_ALREADY_EXISTS)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_1;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_2;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_1,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, test_incarnation_id2, clds_hazard_pointers, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, \"block1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id2, 4 MB, &index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_ALREADY_EXISTS, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_031: [ bsi_local_create_block shall set the block state to CREATED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_027: [ If the block already exists in the hash table then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_028: [ bsi_local_create_block shall call clds_hash_table_find to get the existing block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_026: [ If the state of the found block is CREATED, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_the_block_already_exists_without_commit_bsi_local_create_block_returns_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_1;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_2;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_1,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, test_incarnation_id2, clds_hazard_pointers, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, \"block1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id2, 4 MB, &index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_1, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_031: [ bsi_local_create_block shall set the block state to CREATED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_027: [ If the block already exists in the hash table then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_028: [ bsi_local_create_block shall call clds_hash_table_find to get the existing block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_051: [ If the state of the found block is DELETING, bsi_local_create_block shall fail and return BSI_LOCAL_CREATE_BLOCK_DELETING. ]*/\r\nTEST_FUNCTION(when_the_block_is_deleted_without_commit_bsi_local_create_block_returns_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_1;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_2;\r\n    bool was_sealed;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_1,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, test_incarnation_id2, clds_hazard_pointers, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_insert(hash_table, IGNORED_ARG, \"block1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_value(&hash_table_item_2);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id2, 4 MB, &index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_DELETING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_031: [ bsi_local_create_block shall set the block state to CREATED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_027: [ If the block already exists in the hash table then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_028: [ bsi_local_create_block shall call clds_hash_table_find to get the existing block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_029: [ If the block is not found in the hash table then bsi_local_create_block shall attempt to insert the block item in the hash table again. ]*/\r\nTEST_FUNCTION(when_the_block_already_exists_without_commit_bsi_local_create_block_returns_OK_if_other_is_aborted_after_initial_check)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_CREATE_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_1;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item_2;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_create_block(\"xxx\", test_incarnation_id, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_1,\r\n        false /*insert_fails_already_exists_then_succeeds*/,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"xxx\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n\r\n    expect_bsi_local_create_block(\"block1\", test_incarnation_id2, tls_slot, hash_table, clds_hazard_pointers, &clds_hazard_pointers_thread, &hash_table_item_2,\r\n        true /*insert_fails_already_exists_then_succeeds*/,\r\n        false /*creates_hazard_pointers*/,\r\n        2);\r\n\r\n    // act\r\n    result = bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id2, 4 MB, &index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_1);\r\n    (void)bsi_local_abort_action(index_update_action_2);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_append */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_023: [ On success bsi_local_append shall return BSI_LOCAL_APPEND_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_073: [ bsi_local_append shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_029: [ bsi_local_append shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_092: [ bsi_local_append shall call bsi_local_block_start_append to track the start of the append in the block and pass check_epoch and epoch as arguments. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_115: [ bsi_local_append shall call bsi_local_block_append_get_offset on the append handle to obtain the append offset. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_030: [ bsi_local_append shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_032: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_113: [ On success append_offset shall be set to the new append offset. ]*/\r\nTEST_FUNCTION(bsi_local_append_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append);\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, append_offset);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_092: [ bsi_local_append shall call bsi_local_block_start_append to track the start of the append in the block and pass check_epoch and epoch as arguments. ]*/\r\nTEST_FUNCTION(bsi_local_append_passes_check_epoch_flag_and_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, false, 42, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, false, 42, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append);\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, append_offset);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_023: [ On success bsi_local_append shall return BSI_LOCAL_APPEND_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_073: [ bsi_local_append shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_029: [ bsi_local_append shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_092: [ bsi_local_append shall call bsi_local_block_start_append to track the start of the append in the block and pass check_epoch and epoch as arguments. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_030: [ bsi_local_append shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_032: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_append_twice_on_the_same_block_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result_1;\r\n    BSI_LOCAL_APPEND_RESULT result_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_2;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset_1;\r\n    uint64_t append_offset_2;\r\n    uint64_t second_append_offset = 1 MB;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_2, sizeof(test_block_append_2));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_2, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_offset(&second_append_offset, sizeof(second_append_offset));\r\n\r\n    // act\r\n    result_1 = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset_1, &index_update_action_append_1);\r\n    result_2 = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset_2, &index_update_action_append_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result_1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result_2);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append_1);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append_2);\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, append_offset_1);\r\n    ASSERT_ARE_EQUAL(uint64_t, 1 MB, append_offset_2);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append_1, test_operation_address);\r\n    (void)bsi_local_commit_action(index_update_action_append_2, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_023: [ On success bsi_local_append shall return BSI_LOCAL_APPEND_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_073: [ bsi_local_append shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_029: [ bsi_local_append shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_092: [ bsi_local_append shall call bsi_local_block_start_append to track the start of the append in the block and pass check_epoch and epoch as arguments. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_030: [ bsi_local_append shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_032: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_append_twice_on_2_different_blocks_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result_1;\r\n    BSI_LOCAL_APPEND_RESULT result_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_2;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset_1;\r\n    uint64_t append_offset_2;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block_1));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block_1, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(bsi_local_block_create(4 MB, test_incarnation_id2, clds_hazard_pointers, tls_slot, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .SetReturn(test_bsi_local_block_2);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block2\", test_incarnation_id2, 4 MB, &index_update_action_create_block_2));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block_2, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block2\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block_2, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_2, sizeof(test_block_append_2));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_2, IGNORED_ARG));\r\n\r\n    // act\r\n    result_1 = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset_1, &index_update_action_append_1);\r\n    result_2 = bsi_local_append(bsi_local, \"block2\", 1 MB, true, 0, &append_offset_2, &index_update_action_append_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result_1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result_2);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append_1);\r\n    ASSERT_IS_NOT_NULL(index_update_action_append_2);\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, append_offset_1, \"Append 1 offset\");\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, append_offset_2, \"Append 2 offset\");\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append_1, test_operation_address);\r\n    (void)bsi_local_commit_action(index_update_action_append_2, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_197: [ If the block is not found in the hash table, bsi_local_append shall fail and return BSI_LOCAL_APPEND_BLOCK_NOT_FOUND. ]*/\r\nTEST_FUNCTION(when_finding_the_block_fails_bsi_local_append_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_BLOCK_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_033: [ If any error occurs, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_append_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_033: [ If any error occurs, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(when_creating_the_hazard_pointers_thread_fails_bsi_local_append_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_033: [ If any error occurs, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_hazard_pointers_thread_fails_bsi_local_append_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_024: [ If bsi_local is NULL, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_append_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    uint64_t append_offset;\r\n\r\n    // act\r\n    result = bsi_local_append(NULL, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_025: [ If block_id is NULL, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_append_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, NULL, 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_088: [ If append_size is 0, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_append_with_zero_append_size_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 0, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_114: [ If append_offset is NULL, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_append_with_NULL_append_offset_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1, true, 0, NULL, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_026: [ If index_update_action is NULL, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_append_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_074: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_075: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(when_no_thread_local_hazard_pointer_thread_exists_one_is_created_by_bsi_local_append)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_033: [ If any error occurs, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_append_fails_with_ERROR_bsi_local_append_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1))\r\n        .SetReturn(BSI_LOCAL_BLOCK_APPEND_ERROR);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_033: [ If any error occurs, bsi_local_append shall fail and return BSI_LOCAL_APPEND_ERROR. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_append_get_offset_fails_bsi_local_append_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG))\r\n        .SetReturn(1);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nvoid test_bsi_block_append_fail_with_error(BSI_LOCAL_BLOCK_APPEND_RESULT block_append_result, BSI_LOCAL_APPEND_RESULT expected_result)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_append(test_bsi_local_block, 1 MB, true, 0, IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_append_handle(&test_block_append_1, sizeof(test_block_append_1))\r\n        .SetReturn(block_append_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, expected_result, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_093: [ If bsi_local_block_start_append returns that the block is already sealed, bsi_local_append shall fail and return BSI_LOCAL_APPEND_SEALED. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_append_fails_with_SEALED_bsi_local_append_also_fails_with_SEALED)\r\n{\r\n    test_bsi_block_append_fail_with_error(BSI_LOCAL_BLOCK_APPEND_SEALED, BSI_LOCAL_APPEND_SEALED);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_223: [ If bsi_local_block_start_append returns BSI_LOCAL_BLOCK_APPEND_BLOCK_BUSY, bsi_local_append shall fail and return BSI_LOCAL_APPEND_BLOCK_BUSY. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_append_fails_with_BLOCK_BUSY_bsi_local_append_also_fails_with_BLOCK_BUSY)\r\n{\r\n    test_bsi_block_append_fail_with_error(BSI_LOCAL_BLOCK_APPEND_BLOCK_BUSY, BSI_LOCAL_APPEND_BLOCK_BUSY);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_123: [ If bsi_local_block_start_append returns that the block is full, bsi_local_append shall fail and return BSI_LOCAL_APPEND_BLOCK_FULL. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_append_fails_with_BLOCK_FULL_bsi_local_append_also_fails_with_BLOCK_FULL)\r\n{\r\n    test_bsi_block_append_fail_with_error(BSI_LOCAL_BLOCK_APPEND_BLOCK_FULL, BSI_LOCAL_APPEND_BLOCK_FULL);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_220: [ If bsi_local_block_start_append returns BSI_LOCAL_BLOCK_APPEND_EPOCH_MISMATCH, bsi_local_append shall return fail and BSI_LOCAL_APPEND_EPOCH_MISMATCH. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_append_fails_with_EPOCH_MISMATCH_bsi_local_append_also_fails_with_EPOCH_MISMATCH)\r\n{\r\n    test_bsi_block_append_fail_with_error(BSI_LOCAL_BLOCK_APPEND_EPOCH_MISMATCH, BSI_LOCAL_APPEND_EPOCH_MISMATCH);\r\n\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_030: [ If the state of the block is CREATED, bsi_local_append shall fail and return BSI_LOCAL_APPEND_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_append_also_fails_with_BLOCK_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    uint64_t append_offset;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_039: [ If the state of the block is DELETING, bsi_local_append shall fail and return BSI_LOCAL_APPEND_BLOCK_DELETE_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_append_also_fails_with_BLOCK_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    uint64_t append_offset;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    bool was_sealed;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc())\r\n        .CaptureReturn(&tls_slot);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create())\r\n        .CaptureReturn(&clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_BLOCK_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_seal_block */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_034: [ On success bsi_local_seal_block shall return BSI_LOCAL_SEAL_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_076: [ bsi_local_seal_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_038: [ bsi_local_seal_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_003: [ bsi_local_seal_block shall call bsi_local_block_get_incarnation_id on the block to get the current incarnation id. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_094: [ bsi_local_seal_block shall start the seal by calling bsi_local_block_start_seal. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_040: [ bsi_local_seal_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_119: [ The sequence number returned by bsi_local_block_start_seal shall be assigned to the action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_041: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_seal_block_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    int64_t expected_seq_no;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_seal(test_bsi_local_block, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_seal_sequence_no(&expected_seq_no, sizeof(expected_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, result);\r\n    ASSERT_ARE_EQUAL(int64_t, expected_seq_no, bsi_local_get_action_seq_no(index_update_action_seal));\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_035: [ If bsi_local is NULL, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(bsi_seal_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    // act\r\n    result = bsi_local_seal_block(NULL, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_036: [ If block_id is NULL, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(bsi_seal_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, NULL, test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_002: [ If incarnation_id is NULL then bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(bsi_seal_with_NULL_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", NULL, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_037: [ If index_update_action is NULL, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(bsi_seal_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nstatic void test_when_bsi_local_block_start_seal_fails_bsi_local_seal_block_also_fails(BSI_LOCAL_BLOCK_SEAL_RESULT bsi_local_block_seal_result, BSI_LOCAL_SEAL_RESULT bsi_local_seal_result)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal_1));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_seal(test_bsi_local_block, IGNORED_ARG))\r\n        .SetReturn(bsi_local_block_seal_result);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, bsi_local_seal_result, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_seal_1, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_039: [ If the block is already sealed, bsi_local_seal_block shall return BSI_LOCAL_SEAL_ALREADY_SEALED. ]*/\r\nTEST_FUNCTION(bsi_local_seal_block_when_already_sealed_returns_ALREADY_SEALED)\r\n{\r\n    test_when_bsi_local_block_start_seal_fails_bsi_local_seal_block_also_fails(BSI_LOCAL_BLOCK_SEAL_ALREADY_SEALED, BSI_LOCAL_SEAL_ALREADY_SEALED);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_224: [ If the block fails with BSI_LOCAL_BLOCK_SEAL_BLOCK_BUSY, bsi_local_seal_block shall return BSI_LOCAL_SEAL_BLOCK_BUSY. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_seal_fails_with_BLOCK_BUSY_bsi_local_seal_block_returns_BLOCK_BUSY)\r\n{\r\n    test_when_bsi_local_block_start_seal_fails_bsi_local_seal_block_also_fails(BSI_LOCAL_BLOCK_SEAL_BLOCK_BUSY, BSI_LOCAL_SEAL_BLOCK_BUSY);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_198: [ If the block is not found in the hash table, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_BLOCK_NOT_FOUND. ]*/\r\nTEST_FUNCTION(when_finding_the_block_fails_bsi_local_seal_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_BLOCK_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_032: [ If the state of the block is CREATED, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_seal_block_returns_BLOCK_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_040: [ If the state of the block is DELETING, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_BLOCK_DELETE_PENDING. ]*/\r\nTEST_FUNCTION(when_block_delete_not_committed_bsi_local_seal_block_returns_BLOCK_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_BLOCK_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_delete_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_042: [ If any error occurs when sealing the block, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_seal_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_042: [ If any error occurs when sealing the block, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_start_seal_fails_bsi_local_seal_block_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_seal(test_bsi_local_block, IGNORED_ARG))\r\n        .SetReturn(BSI_LOCAL_BLOCK_SEAL_ERROR);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_042: [ If any error occurs when sealing the block, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(when_registering_the_hazard_pointers_thread_fails_bsi_local_seal_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_042: [ If any error occurs when sealing the block, bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_hazard_pointers_thread_in_the_thread_local_storage_fails_bsi_local_seal_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_077: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_078: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(when_the_hazard_pointers_thread_does_not_exist_in_thread_local_storage_bsi_local_seal_block_creates_a_new_one)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_seal(test_bsi_local_block, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_034: [ On success bsi_local_seal_block shall return BSI_LOCAL_SEAL_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_076: [ bsi_local_seal_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_038: [ bsi_local_seal_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_094: [ bsi_local_seal_block shall start the seal by calling bsi_local_block_start_seal. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_040: [ bsi_local_seal_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_041: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_seal_block_after_one_append_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_seal(test_bsi_local_block, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n    (void)bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_004: [ If the current incarnation id of the block does not match incarnation_id then bsi_local_seal_block shall fail and return BSI_LOCAL_SEAL_OLD_BLOCK. ]*/\r\nTEST_FUNCTION(bsi_local_seal_block_with_different_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SEAL_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(test_bsi_local_block, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id2, &index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OLD_BLOCK, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_delete_block */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_005: [ incarnation_id may be NULL ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_043: [ On success bsi_local_delete_block shall return BSI_LOCAL_DELETE_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_079: [ bsi_local_delete_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_047: [ bsi_local_delete_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_142: [ bsi_local_delete_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_041: [ bsi_local_delete_block shall update the state of the block to DELETING. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_052: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_023: [ On success bsi_local_delete_block shall call bsi_local_block_is_block_seal_started on the block and report the result in was_sealed. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    bool expected_seal_started = false;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n    ASSERT_IS_FALSE(was_sealed);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_005: [incarnation_id may be NULL]*/\r\n/* Tests_SRS_BSI_LOCAL_01_043: [ On success bsi_local_delete_block shall return BSI_LOCAL_DELETE_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_079: [ bsi_local_delete_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_047: [ bsi_local_delete_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_142: [ bsi_local_delete_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_041: [ bsi_local_delete_block shall update the state of the block to DELETING. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_052: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_023: [ On success bsi_local_delete_block shall call bsi_local_block_is_block_seal_started on the block and report the result in was_sealed. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_succeeds_2)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"xxx\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"xxx\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    bool expected_seal_started = false;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"xxx\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n    ASSERT_IS_FALSE(was_sealed);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_023: [ On success bsi_local_delete_block shall call bsi_local_block_is_block_seal_started on the block and report the result in was_sealed. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_after_sealed_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    bool expected_seal_started = true;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n    ASSERT_IS_TRUE(was_sealed);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_043: [ On success bsi_local_delete_block shall return BSI_LOCAL_DELETE_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_079: [ bsi_local_delete_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_047: [ bsi_local_delete_block shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_142: [ bsi_local_delete_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_007: [ If incarnation_id is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_008: [ bsi_local_delete_block shall get the incarnation id of the found block by calling bsi_local_block_get_incarnation_id. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_041: [ bsi_local_delete_block shall update the state of the block to DELETING. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_052: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_023: [ On success bsi_local_delete_block shall call bsi_local_block_is_block_seal_started on the block and report the result in was_sealed. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_matching_incarnation_id_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(IGNORED_ARG, IGNORED_ARG));\r\n    bool expected_seal_started = false;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n    ASSERT_IS_FALSE(was_sealed);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_044: [ If bsi_local is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    // act\r\n    result = bsi_local_delete_block(NULL, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_044: [ If bsi_local is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_bsi_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    // act\r\n    result = bsi_local_delete_block(NULL, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_045: [ If block_id is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, NULL, NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_045: [ If block_id is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_block_id_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, NULL, test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_046: [ If index_update_action is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, NULL, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_046: [ If index_update_action is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_index_update_action_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, NULL, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_022: [ If was_sealed is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_was_sealed_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_022: [ If was_sealed is NULL, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_delete_block_with_NULL_was_sealed_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_052: [ If the block is not found then bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_NOT_FOUND. ]*/\r\nTEST_FUNCTION(when_the_block_is_not_found_by_clds_hash_table_find_while_deleting_bsi_local_delete_block_returns_NOT_FOUND)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/*Tests_SRS_BSI_LOCAL_42_034: [ If the state of the block is CREATED, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_delete_block_returns_BLOCK_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/*Tests_SRS_BSI_LOCAL_42_034: [ If the state of the block is CREATED, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_delete_block_with_incarnation_id_returns_BLOCK_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_050: [ If the state of the block is DELETING, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_BLOCK_DELETE_PENDING. ]*/\r\nTEST_FUNCTION(when_block_delete_not_committed_second_bsi_local_delete_block_returns_BLOCK_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block_2;\r\n    bool was_sealed;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block_2, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_BLOCK_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_050: [ If the state of the block is DELETING, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_BLOCK_DELETE_PENDING. ]*/\r\nTEST_FUNCTION(when_block_delete_not_committed_second_bsi_local_delete_block_with_incarnation_id_returns_BLOCK_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block_2;\r\n    bool was_sealed;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block_2, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_BLOCK_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_009: [ If the block in the index has an incarnation id that does not match incarnation_id then bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_OLD_BLOCK. ]*/\r\nTEST_FUNCTION(when_get_incarnation_id_does_not_match_block_to_delete_returns_OLD_BLOCK)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id2, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OLD_BLOCK, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_delete_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_delete_block_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_creating_a_new_hazard_pointers_thread_fails_bsi_local_delete_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_creating_a_new_hazard_pointers_thread_fails_bsi_local_delete_block_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_new_hazard_pointers_thread_in_the_thread_local_storage_fails_bsi_local_delete_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_053: [ If any error occurs when deleting the block, bsi_local_delete_block shall fail and return BSI_LOCAL_DELETE_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_new_hazard_pointers_thread_in_the_thread_local_storage_fails_bsi_local_delete_block_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_080: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_081: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(when_no_hazard_pointers_thread_is_in_the_local_thread_storage_bsi_local_delete_block_creates_a_new_one)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, clds_hazard_pointers_thread));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    bool expected_seal_started = false;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_080: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_081: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(when_no_hazard_pointers_thread_is_in_the_local_thread_storage_bsi_local_delete_block_with_incarnation_id_creates_a_new_one)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_DELETE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, clds_hazard_pointers_thread));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_get_incarnation_id(IGNORED_ARG, IGNORED_ARG));\r\n    bool expected_seal_started = false;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_is_block_seal_started(IGNORED_ARG, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_block_seal_started(&expected_seal_started, sizeof(expected_seal_started));\r\n\r\n    // act\r\n    result = bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_delete_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_set_block_epoch */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_199: [ If bsi_local is NULL, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_with_NULL_bsi_local_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(NULL, \"block1\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_200: [ If block_id is NULL, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, NULL, 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_201: [ If index_update_action is NULL, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, NULL, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_219: [ If previous_operation_address is NULL, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_with_NULL_previous_operation_address_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_202: [ bsi_local_set_block_epoch shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_205: [ bsi_local_set_block_epoch shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_206: [ bsi_local_set_block_epoch shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_207: [ If the block is not found then bsi_local_delete_block shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_NOT_FOUND. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_when_block_not_found_fails)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block42\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_202: [ bsi_local_set_block_epoch shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_203: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_204: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_205: [ bsi_local_set_block_epoch shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_206: [ bsi_local_set_block_epoch shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_211: [ bsi_local_set_block_epoch shall call bsi_local_block_start_set_block_epoch to set the epoch on the block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_212: [ If bsi_local_block_set_block_epoch returns BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_OK, bsi_local_set_block_epoch shall succeed and return BSI_LOCAL_SET_BLOCK_EPOCH_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_209: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_succeeds)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block42\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block42\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_set_block_epoch(IGNORED_ARG, 42, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_set_block_epoch, test_set_block_epoch_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_202: [ bsi_local_set_block_epoch shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_203: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_204: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_205: [ bsi_local_set_block_epoch shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_206: [ bsi_local_set_block_epoch shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_211: [ bsi_local_set_block_epoch shall call bsi_local_block_start_set_block_epoch to set the epoch on the block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_212: [ If bsi_local_block_set_block_epoch returns BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_OK, bsi_local_set_block_epoch shall succeed and return BSI_LOCAL_SET_BLOCK_EPOCH_OK. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_208: [ The sequence number returned by bsi_local_block_start_set_block_epoch shall be assigned to the action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_209: [ On success index_update_action shall be set to the new index update action handle. ]*/\r\nTEST_FUNCTION(bsi_local_set_block_epoch_when_hazard_pointers_thread_already_exists_succeeds)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block42\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block42\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    int64_t expected_sequence_no = 42;\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_set_block_epoch(IGNORED_ARG, 42, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_set_block_epoch_sequence_no(&expected_sequence_no, sizeof(expected_sequence_no));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_OK, result);\r\n    ASSERT_ARE_EQUAL(int64_t, expected_sequence_no, bsi_local_get_action_seq_no(index_update_action_set_block_epoch));\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_set_block_epoch, test_set_block_epoch_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_210: [ If any error occurs when deleting the block, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ERROR. ]*/\r\nTEST_FUNCTION(when_underlying_calls_fail_bsi_local_set_block_epoch_also_fails)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block42\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer)).CallCannotFail();\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL).CallCannotFail();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block42\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_set_block_epoch(IGNORED_ARG, 42, IGNORED_ARG));\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n            // assert\r\n            ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_ERROR, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nstatic void test_bsi_local_set_block_epoch_with_error_code(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_RESULT block_result, BSI_LOCAL_SET_BLOCK_EPOCH_RESULT expected_result)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_HANDLE clds_hazard_pointers;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create_with_hp(&tls_slot, &hash_table, &kvp_hash_table, &clds_hazard_pointers);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(clds_hazard_pointers))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block42\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block42\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_start_set_block_epoch(IGNORED_ARG, 42, IGNORED_ARG))\r\n        .SetReturn(block_result);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block42\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, expected_result, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_213: [ If bsi_local_block_set_block_epoch returns BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_SEALED, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_SEALED. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_set_block_epoch_fails_with_SEALED_bsi_local_set_block_epoch_returns_SEALED)\r\n{\r\n    test_bsi_local_set_block_epoch_with_error_code(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_SEALED, BSI_LOCAL_SET_BLOCK_EPOCH_SEALED);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_225: [ If bsi_local_block_set_block_epoch returns BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_BLOCK_BUSY, bsi_local_set_block_epoch shall succeed and return BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_BUSY. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_set_block_epoch_fails_with_BLOCK_BUSY_bsi_local_set_block_epoch_returns_BLOCK_BUSY)\r\n{\r\n    test_bsi_local_set_block_epoch_with_error_code(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_BLOCK_BUSY, BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_BUSY);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_214: [ If bsi_local_block_set_block_epoch returns BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_ALREADY_HAS_NEWER, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_ALREADY_HAS_NEWER. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_set_block_epoch_fails_with_ALREADY_HAS_NEWER_bsi_local_set_block_epoch_returns_ALREADY_HAS_NEWER)\r\n{\r\n    test_bsi_local_set_block_epoch_with_error_code(BSI_LOCAL_BLOCK_SET_BLOCK_EPOCH_ALREADY_HAS_NEWER, BSI_LOCAL_SET_BLOCK_EPOCH_ALREADY_HAS_NEWER);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_221: [ If the block state is CREATED, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_ALLOCATE_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_set_block_epoch_returns_BLOCK_ALLOCATE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block1\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_ALLOCATE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_222: [ If the block state is DELETING, bsi_local_set_block_epoch shall fail and return BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_DELETE_PENDING. ]*/\r\nTEST_FUNCTION(when_delete_block_not_committed_bsi_local_set_block_epoch_returns_BLOCK_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    bool was_sealed;\r\n    BSI_LOCAL_SET_BLOCK_EPOCH_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_block_epoch(bsi_local, \"block1\", 42, &index_update_action_set_block_epoch, &previous_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_BLOCK_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_find_block */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_103: [ bsi_local_find_block shall lookup the block identified by block_id and on success store a non-NULL handle to the block in block. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_106: [ bsi_local_find_block shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_109: [ bsi_local_find_block shall find the block block_id in the hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_110: [ bsi_local_find_block shall increment the reference count for the block by calling bsi_local_block_inc_ref. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_037: [ bsi_local_find_block shall succeed and return BSI_LOCAL_FIND_BLOCK_OK. ]*/\r\nTEST_FUNCTION(bsi_local_find_block_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_inc_ref(test_bsi_local_block));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_FIND_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_OK, result);\r\n    ASSERT_IS_NOT_NULL(block);\r\n\r\n    // cleanup\r\n    bsi_local_block_dec_ref(block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_104: [ If bsi_local is NULL, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_find_block_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n\r\n    // act\r\n    result = bsi_local_find_block(NULL, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_105: [ If block_id is NULL, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_find_block_with_NULL_block_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, NULL, &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_036: [ If block is NULL, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_find_block_with_NULL_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_112: [ If the block block_id is not found in the underlying hash table, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_NOT_FOUND. ]*/\r\nTEST_FUNCTION(when_the_block_is_not_found_bsi_local_find_block_returns_NOT_FOUND)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block2\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block2\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_033: [ If the state of the block is CREATED, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_PENDING. ]*/\r\nTEST_FUNCTION(when_block_create_not_committed_bsi_local_find_block_returns_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_042: [ If the state of the block is DELETING, bsi_local_find_block shall fail and return BSI_LOCAL_FIND_BLOCK_DELETING. ]*/\r\nTEST_FUNCTION(when_block_delete_not_committed_bsi_local_find_block_returns_DELETE_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bool was_sealed;\r\n\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, clds_hazard_pointers_thread, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_DELETING, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_107: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_108: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(bsi_local_find_block_succeeds_with_new_hazard_pointers_thread)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE another_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&another_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(hash_table, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&another_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_inc_ref(test_bsi_local_block));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_FIND_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_OK, result);\r\n    ASSERT_IS_NOT_NULL(block);\r\n\r\n    // cleanup\r\n    bsi_local_block_dec_ref(block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_111: [ If any error occurs, bsi_local_find_block shall return BSI_LOCAL_FIND_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(when_creating_a_new_hazard_pointers_thread_fails_bsi_local_find_block_returns_ERROR)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_111: [ If any error occurs, bsi_local_find_block shall return BSI_LOCAL_FIND_BLOCK_ERROR. ]*/\r\nTEST_FUNCTION(when_setting_the_new_hazard_pointers_thread_in_the_tls_slot_fails_bsi_local_find_block_returns_ERROR)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_BLOCK_HANDLE block;\r\n    BSI_LOCAL_FIND_BLOCK_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_find_block(bsi_local, \"block1\", &block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_FIND_BLOCK_RESULT, BSI_LOCAL_FIND_BLOCK_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_set_value */\r\n\r\nstatic void expect_bsi_local_set_value_override_local_value(\r\n    const char* key,\r\n    const UUID_T etag,\r\n    DWORD tls_slot,\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table,\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE* clds_hazard_pointers_thread,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item,\r\n    BSI_LOCAL_VALUE_HANDLE previous_value,\r\n    bool creates_hazard_pointers,\r\n    uint64_t value_count,\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value)\r\n{\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n\r\n    if (creates_hazard_pointers)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n            .CaptureReturn(clds_hazard_pointers_thread);\r\n        STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n            .ValidateArgumentValue_lpTlsValue((LPVOID*)clds_hazard_pointers_thread);\r\n    }\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(UUID_generate(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create(IGNORED_ARG, etag))\r\n        .SetReturn(bsi_local_value);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_set_value(kvp_hash_table, IGNORED_ARG, (void*)key, IGNORED_ARG, NULL, NULL, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(clds_hazard_pointers_thread);\r\n\r\n    if (previous_value != NULL)\r\n    {\r\n        STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(previous_value));\r\n    }\r\n    else\r\n    {\r\n        if (value_count != 0)\r\n        {\r\n            STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], value_count))\r\n                .CallCannotFail();\r\n        }\r\n    }\r\n}\r\n\r\nstatic void expect_bsi_local_set_value(\r\n    const char* key,\r\n    const UUID_T etag,\r\n    DWORD tls_slot,\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table,\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE* clds_hazard_pointers_thread,\r\n    CLDS_HASH_TABLE_ITEM** hash_table_item,\r\n    BSI_LOCAL_VALUE_HANDLE previous_value,\r\n    bool creates_hazard_pointers,\r\n    uint64_t value_count)\r\n{\r\n    expect_bsi_local_set_value_override_local_value(\r\n        key,\r\n        etag,\r\n        tls_slot,\r\n        kvp_hash_table,\r\n        clds_hazard_pointers_thread,\r\n        hash_table_item,\r\n        previous_value,\r\n        creates_hazard_pointers,\r\n        value_count,\r\n        test_bsi_local_value);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_146: [ If bsi_local is NULL, bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_ERROR. ] */\r\nTEST_FUNCTION(bsi_local_set_value_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n\r\n    // act\r\n    result = bsi_local_set_value(NULL, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_147: [ If key is NULL, bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_ERROR. ] */\r\nTEST_FUNCTION(bsi_local_set_value_with_NULL_key_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, NULL, test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_012: [ If incarnation_id is NULL then bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_value_with_NULL_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", NULL, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_148: [ If index_update_action is NULL, bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_value_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, NULL, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_149: [ If replaced_value is NULL, bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_set_value_with_NULL_replaced_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_145: [ On success bsi_local_set_value shall return BSI_LOCAL_SET_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_188: [ bsi_local_set_value shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_150: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_151: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_152: [ bsi_local_set_value shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_156: [ bsi_local_set_value shall create a structure to hold the new key, incarnation id, value entry. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_189: [ bsi_local_set_value shall clone the key and store it in the allocated structure. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_028: [ bsi_local_set_value shall generate a new etag UUID for the key. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_153: [ bsi_local_set_value shall replace the value for key in the hash table by calling clds_hash_table_set_value with the newly created key-value entry. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_155: [ If clds_hash_table_set_value does not return a previous value, bsi_local_set_value shall set replaced_value to NULL. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_054: [ If clds_hash_table_set_value does not return a previous value then bsi_local_set_value shall log the metric BSI_LOCAL_VALUE_COUNT with the total count of key value pairs in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_003: [ bsi_local_set_value shall set the value state to CREATED. ] */\r\nTEST_FUNCTION(bsi_local_set_value_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item,\r\n        NULL,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    int32_t state = interlocked_add(&index_value->value_state, 0);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int32_t, 1, state);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_clds_hazard_pointers_register_thread_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_mocked_TlsSetValue_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_key_value_pair_entry_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_mallocAndStrcpy_s_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_bsi_local_value_create_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create(IGNORED_ARG, NULL))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // cloned key\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_node_create_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create(IGNORED_ARG, NULL));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // cloned key\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_node_inc_ref_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create(IGNORED_ARG, NULL));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG))\r\n        .SetReturn(1);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // cloned key\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_160: [ If any error occurs, bsi_local_set_value shall fail and return BSI_LOCAL_SET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_set_value_fails_bsi_local_set_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_create(IGNORED_ARG, NULL));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_set_value(kvp_hash_table, IGNORED_ARG, \"key1\", IGNORED_ARG, NULL, NULL, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .SetReturn(CLDS_HASH_TABLE_SET_VALUE_ERROR);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG))\r\n        .ValidateArgumentValue_item(&hash_table_item);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG)); // cloned key\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(test_bsi_local_value));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_154: [ If clds_hash_table_set_value returns a previous value that was replaced, bsi_local_set_value shall return it in the replaced_value argument. ]*/\r\nTEST_FUNCTION(bsi_local_set_value_when_a_replaced_item_is_returned_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item,\r\n        NULL,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &previous_value));\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item,\r\n        test_bsi_local_value,\r\n        false /*creates_hazard_pointers*/,\r\n        1);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, previous_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value_2);\r\n    (void)bsi_local_abort_action(index_update_action_set_value_1);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_279: [ If clds_hash_table_set_value returns a previous value that was replaced, but the replaced value state is DELETING or DELETED then bsi_local_set_value shall set replaced_value to NULL. ]*/\r\nTEST_FUNCTION(bsi_local_set_value_when_a_replaced_item_is_returned_but_is_deleting_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_SET_VALUE_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item,\r\n        NULL,\r\n        true /*creates_hazard_pointers*/,\r\n        1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &previous_value));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value_1, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item,\r\n        NULL,\r\n        false /*creates_hazard_pointers*/,\r\n        0);\r\n\r\n    // act\r\n    result = bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &previous_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, result);\r\n    ASSERT_IS_NULL(previous_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value_2);\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_get_value */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_161: [ If bsi_local is NULL, bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n\r\n    // act\r\n    result = bsi_local_get_value(NULL, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_162: [ If key is NULL, bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_with_NULL_key_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, NULL, &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_163: [ If bsi_local_value is NULL, bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_with_NULL_bsi_local_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_192: [ bsi_local_get_value shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_164: [ bsi_local_get_value shall lookup the key in the key-value hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_165: [ On success, bsi_local_get_value shall return BSI_LOCAL_GET_VALUE_OK and set bsi_local_value to the value that was found in the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_166: [ bsi_local_get_value shall increment the reference count for the value returned in bsi_local_value. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, bsi_local_value);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_196: [ If the state of the key-value pair is DELETING then bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_DELETING. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_while_deleting_returns_DELETING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_DELETING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_197: [ If the state of the key-value pair is not COMMITTED then bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_PENDING. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_without_commit_returns_PENDING)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_PENDING, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_165: [ On success, bsi_local_get_value shall return BSI_LOCAL_GET_VALUE_OK and set bsi_local_value to the value that was found in the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_190: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_191: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(bsi_local_get_value_creates_a_hazard_pointers_thread_handle_if_needed)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, bsi_local_value);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_167: [ If the key is not found, bsi_local_get_value shall return BSI_LOCAL_GET_VALUE_NOT_FOUND. ]*/\r\nTEST_FUNCTION(when_the_key_is_not_found_bsi_local_get_value_returns_NOT_FOUND)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_168: [ If any error is encountered bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_NOT_ERROR. ]*/\r\nTEST_FUNCTION(when_clds_hazard_pointers_register_thread_fails_bsi_local_get_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_168: [ If any error is encountered bsi_local_get_value shall fail and return BSI_LOCAL_GET_VALUE_NOT_ERROR. ]*/\r\nTEST_FUNCTION(when_mocked_TlsSetValue_fails_bsi_local_get_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_GET_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_VALUE_HANDLE bsi_local_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_get_value(bsi_local, \"key1\", &bsi_local_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_remove_value */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_169: [ If bsi_local is NULL, bsi_delete_value shall fail and return BSI_LOCAL_DELETE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    // act\r\n    result = bsi_local_remove_value(NULL, \"key1\", NULL, NULL, &index_update_action, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_169: [ If bsi_local is NULL, bsi_delete_value shall fail and return BSI_LOCAL_DELETE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_bsi_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    // act\r\n    result = bsi_local_remove_value(NULL, \"key1\", test_incarnation_id, NULL, &index_update_action, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_170: [ If key is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_key_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, NULL, NULL, NULL, &index_update_action, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_170: [ If key is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_key_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, NULL, test_incarnation_id, NULL, &index_update_action, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_193: [ If index_update_action is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_index_update_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, NULL, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_193: [ If index_update_action is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_index_update_action_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, NULL, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_194: [ If removed_value is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_removed_value_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_194: [ If removed_value is NULL, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_NULL_removed_value_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_014: [ incarnation_id may be NULL. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_195: [ bsi_local_remove_value shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_172: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_173: [ bsi_local_remove_value shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_020: [ Else (incarnation_id is NULL): ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_176: [ On success bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_004: [ bsi_local_remove_value shall update the state of the key-value pair to DELETING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n\r\n    // act\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n    int32_t state = interlocked_add(&index_value->value_state, 0);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int32_t, 3, state);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, removed_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_005: [ If the state of the value is CREATED, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_PENDING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_with_created_state_returns_pending)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 1);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_006: [ If the state of the value is DELETING, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_DELETE_PENDING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_with_deleting_state_returns_delete_pending)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 3);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_017: [ If the key is not found, bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_NOT_FOUND. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_bad_state_returns_error)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 4);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_005: [ If the state of the value is CREATED, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_PENDING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_with_created_state_returns_pending_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 1);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_006: [ If the state of the value is DELETING, bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_DELETE_PENDING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_with_deleting_state_returns_delete_pending_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 3);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_DELETE_PENDING, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_017: [ If the key is not found, bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_NOT_FOUND. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_bad_state_returns_error_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 4);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_195: [ bsi_local_remove_value shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_172: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_173: [ bsi_local_remove_value shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_015: [ If incarnation_id is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_016: [ bsi_local_remove_value shall lookup the key in the key-value hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_176: [ On success bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_004: [ bsi_local_remove_value shall update the state of the key-value pair to DELETING. ] */\r\nTEST_FUNCTION(bsi_local_remove_value_with_incarnation_id_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n\r\n    // act\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n    int32_t state = interlocked_add(&index_value->value_state, 0);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int32_t, 3, state);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, removed_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_195: [ bsi_local_remove_value shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_172: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_173: [ bsi_local_remove_value shall allocate memory for a new index update action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_015: [ If incarnation_id is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_016: [ bsi_local_remove_value shall lookup the key in the key-value hash table by using clds_hash_table_find. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_176: [ On success bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_004: [ bsi_local_remove_value shall update the state of the key-value pair to DELETING. ] */\r\n/* Tests_SRS_BSI_LOCAL_04_011: [ If etag is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_012: [ bsi_local_remove_value shall get the value's etag by calling bsi_local_value_get_etag. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_etag_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_etag(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n\r\n    // act\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n\r\n    // TODO: Replace NIL_GUID below with test_etag when bsi_local_set_value implements generating etags (will have to mock uuid generate).\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, test_etag, &index_update_action_remove_value, &removed_value);\r\n    int32_t state = interlocked_add(&index_value->value_state, 0);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int32_t, 3, state);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, removed_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_176: [ On success bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_171: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_creates_a_hazard_pointer_thread_handle_when_needed)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, removed_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_176: [ On success bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_OK and index_update_action shall be set to the new index update action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_171: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_incarnation_id_creates_a_hazard_pointer_thread_handle_when_needed)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_inc_ref(test_bsi_local_value));\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, result);\r\n    ASSERT_ARE_EQUAL(void_ptr, test_bsi_local_value, removed_value);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_remove_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_017: [ If the key is not found, bsi_local_remove_value shall return BSI_LOCAL_REMOVE_VALUE_NOT_FOUND. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_incarnation_id_when_the_key_is_not_found_during_find_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_NOT_FOUND, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_134: [ bsi_local_remove_value shall get the found value incarnation ID by calling bsi_local_value_get_incarnation_id. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_018: [ If the value found by key has an incarnation id that does not match incarnation_id then bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_OLD_KEY. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_incarnation_id_different_than_incarnation_id_in_index_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id2, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OLD_KEY, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_011: [ If etag is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_012: [ bsi_local_remove_value shall get the value's etag by calling bsi_local_value_get_etag. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_013: [ If the value found by key has an etag that does not match etag then bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ETAG_MISMATCH. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_etag_different_than_etag_in_index_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_etag(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    UUID_T etag = {\r\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\r\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42\r\n    };\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, etag, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ETAG_MISMATCH, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_011: [ If etag is not NULL then: ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_012: [ bsi_local_remove_value shall get the value's etag by calling bsi_local_value_get_etag. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(bsi_local_remove_value_with_etag_fails_when_bsi_local_value_get_etag_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(kvp_hash_table, IGNORED_ARG, \"key1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_incarnation_id(test_bsi_local_value, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_etag(test_bsi_local_value, IGNORED_ARG))\r\n        .SetReturn(MU_FAILURE);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, test_etag, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_remove_value_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_allocating_the_index_update_action_fails_bsi_local_remove_value_with_incarnation_id_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE previous_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &previous_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_registering_the_hazard_pointer_thread_fails_bsi_local_remove_value_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_registering_the_hazard_pointer_thread_fails_bsi_local_remove_value_with_incarnation_id_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_mocked_TlsSetValue_fails_bsi_local_remove_value_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_179: [ If any error is encountered bsi_local_remove_value shall fail and return BSI_LOCAL_REMOVE_VALUE_ERROR. ]*/\r\nTEST_FUNCTION(when_mocked_TlsSetValue_fails_bsi_local_remove_value_with_incarnation_id_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_REMOVE_VALUE_RESULT result;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    DWORD tls_slot;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_ERROR, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_commit_action */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_054: [ bsi_local_commit_action shall free the resources associated with the action handle. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_056: [ bsi_local_commit_action shall evaluate the type of action that is being committed. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_057: [ For create block actions, the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_096: [ For create block actions bsi_local_commit_action shall pass the operation_address to the block by calling bsi_local_block_complete_allocate. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_create_block_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE ht_1;\r\n    CLDS_HASH_TABLE_HANDLE ht_2;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &ht_1, &ht_2);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_allocate(test_bsi_local_block, test_operation_address));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_CREATE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_create_block, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_055: [ If action is NULL, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_with_NULL_action_handle_fails)\r\n{\r\n    // arrange\r\n    int result;\r\n\r\n    // act\r\n    result = bsi_local_commit_action(NULL, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_102: [ If operation_address is NULL, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_with_NULL_operation_address_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_create_block, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_create_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_complete_allocate_fails_bsi_local_commit_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_allocate(test_bsi_local_block, test_operation_address))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_create_block, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_create_block, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_058: [ For append actions, the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_097: [ For append actions bsi_local_commit_action shall pass the operation_address to the block append by calling bsi_local_block_complete_append. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_append_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE ht_1;\r\n    CLDS_HASH_TABLE_HANDLE ht_2;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &ht_1, &ht_2);\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_append(test_block_append_1, test_operation_address));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_dec_ref(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_APPEND_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_complete_append_fails_bsi_local_commit_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_append(test_block_append_1, test_operation_address))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_append, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_059: [ For seal actions, the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_098: [ For seal actions bsi_local_commit_action shall pass the operation_address to the block append by calling bsi_local_block_complete_seal. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_seal_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE ht_1;\r\n    CLDS_HASH_TABLE_HANDLE ht_2;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &ht_1, &ht_2);\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_seal(test_bsi_local_block, test_operation_address));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_SEAL_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_complete_seal_fails_bsi_local_commit_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_seal(test_bsi_local_block, test_operation_address))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_commit_action(index_update_action_seal, test_operation_address);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_044: [ For delete block actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_045: [ bsi_local_commit_action shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_043: [ bsi_local_commit_action shall remove the item from the table by calling clds_hash_table_delete_key_value with the saved hash table item. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_055: [ bsi_local_commit_action shall log the metric BSI_LOCAL_BLOCK_COUNT with the total count of blocks in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_060: [ the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_099: [ For delete block actions operation_address shall be ignored. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_delete_action_and_removes_from_hash_table)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_044: [ For delete block actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_045: [ bsi_local_commit_action shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_043: [ bsi_local_commit_action shall remove the item from the table by calling clds_hash_table_delete_key_value with the saved hash table item. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_055: [ bsi_local_commit_action shall log the metric BSI_LOCAL_BLOCK_COUNT with the total count of blocks in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_060: [ the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_099: [ For delete block actions operation_address shall be ignored. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_delete_action_with_incarnation_id_and_removes_from_hash_table)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_046: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_047: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_delete_action_and_removes_from_hash_table_with_new_hazards_pointer_thread)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, clds_hazard_pointers_thread));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_046: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_047: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_delete_action_with_incarnation_id_and_removes_from_hash_table_with_new_hazards_pointer_thread)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, clds_hazard_pointers_thread));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_049: [ bsi_local_commit_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with the sequence number of the delete from the hash table. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_for_delete_action_calls_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_049: [ bsi_local_commit_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with the sequence number of the delete from the hash table. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_for_delete_action_with_incarnation_id_calls_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_DELETE_BLOCK_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_clds_hazard_pointers_register_thread_fails_bsi_local_commit_action_for_delete_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_clds_hazard_pointers_register_thread_fails_bsi_local_commit_action_for_delete_action_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_TlsSetValue_fails_bsi_local_commit_action_for_delete_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_TlsSetValue_fails_bsi_local_commit_action_for_delete_action_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_215: [ For set block epoch delete actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_216: [ bsi_local_commit_action shall call bsi_local_block_complete_set_block_epoch passing as argument the operation address and the previous operation address pointer passed to bsi_local_set_block_epoch. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_217: [ the hash table item referenced by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_054: [ bsi_local_commit_action shall free the resources associated with the action handle. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_for_set_block_epoch_action_frees_resources)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_BLOCK_EPOCH_RESULT, BSI_LOCAL_SET_BLOCK_EPOCH_OK, bsi_local_set_block_epoch(bsi_local, \"block1\", 42, &index_update_action_set_block_epoch, &previous_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_complete_set_block_epoch(IGNORED_ARG, test_operation_address, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_previous_set_block_epoch_operation_address(&test_previous_set_block_epoch_address, sizeof(test_previous_set_block_epoch_address));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer))\r\n        .SetReturn(100);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_SET_BLOCK_EPOCH_LATENCY], 100));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_set_block_epoch, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(void_ptr, test_previous_set_block_epoch_address, previous_operation_address);\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_delete_key_value_fails_bsi_local_commit_action_for_delete_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(CLDS_HASH_TABLE_DELETE_ERROR);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_delete_key_value_fails_bsi_local_commit_action_for_delete_action_with_incarnation_id_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    bool was_sealed;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(hash_table, clds_hazard_pointers_thread, \"block1\", hash_table_item, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(CLDS_HASH_TABLE_DELETE_ERROR);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_delete, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_delete);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_180: [ For set value actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_196: [ - the operation address shall be marked on the value set by the action by calling bsi_local_value_set_operation_address with the argument set to operation_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_182: [ - the value set by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_001: [ For set value actions, the state of the block shall be changed from CREATED to COMMITTED. ] */\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_the_set_value_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_value_set_operation_address(test_bsi_local_value, test_operation_address));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    result = bsi_local_commit_action(index_update_action_set_value, test_operation_address);\r\n    int32_t state = interlocked_add(&index_value->value_state, 0);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int32_t, 2, state);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_180: [ For set value actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_196: [ - the operation address shall be marked on the value set by the action by calling bsi_local_value_set_operation_address with the argument set to operation_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_182: [ - the value set by the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_001: [ For set value actions, the state of the block shall be changed from CREATED to COMMITTED. ] */\r\nTEST_FUNCTION(bsi_local_commit_action_fails_for_the_set_value_action_when_item_state_is_not_created)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    volatile INDEX_VALUE* index_value = CLDS_HASH_TABLE_GET_VALUE(INDEX_VALUE, hash_table_item);\r\n    interlocked_exchange(&index_value->value_state, 3);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_set_value, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_181: [ - the replaced value referenced by the action shall be released. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_the_previously_replaced_item)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* replaced_hash_table_item;\r\n    CLDS_HASH_TABLE_ITEM* second_hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&replaced_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&second_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value_1, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_value_set_operation_address(test_bsi_local_value, test_operation_address));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(replaced_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_set_value_2, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_100: [ If any error occurs during the commit of the action, bsi_local_commit_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_bsi_local_value_set_operation_address_fails_bsi_local_commit_action_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_value_set_operation_address(test_bsi_local_value, test_operation_address))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_set_value, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_009: [ For remove value actions: ] */\r\n/* Tests_SRS_BSI_LOCAL_01_183: [ For remove value actions the deleted value associated with the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_056: [ For remove value actions, bsi_local_commit_action shall log the metric BSI_LOCAL_VALUE_COUNT with the total count of key value pairs in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_002: [ For remove value actions, bsi_local_commit_action shall remove the item from the table by calling clds_hash_table_delete_key_value with the saved hash table item. ] */\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_the_remove_value_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(kvp_hash_table, IGNORED_ARG, \"key1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_remove_value, test_remove_value_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_009: [ For remove value actions: ] */\r\n/* Tests_SRS_BSI_LOCAL_01_183: [ For remove value actions the deleted value associated with the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_056: [ For remove value actions, bsi_local_commit_action shall log the metric BSI_LOCAL_VALUE_COUNT with the total count of key value pairs in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_002: [ For remove value actions, bsi_local_commit_action shall remove the item from the table by calling clds_hash_table_delete_key_value with the saved hash table item. ] */\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_the_remove_value_with_incarnation_id_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(kvp_hash_table, IGNORED_ARG, \"key1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_remove_value, test_remove_value_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_008: [ If the item was successfully deleted from the hash table then bsi_local_commit_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with the sequence number of the delete from the hash table. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_for_remove_value_action_calls_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(kvp_hash_table, IGNORED_ARG, \"key1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_remove_value, test_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_009: [ For remove value actions: ] */\r\n/* Tests_SRS_BSI_LOCAL_01_183: [ For remove value actions the deleted value associated with the action shall be released. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_002: [ For remove value actions, bsi_local_commit_action shall remove the item from the table by calling clds_hash_table_delete_key_value with the saved hash table item. ] */\r\n/* Tests_SRS_BSI_LOCAL_42_278: [ If the remove from the hash table fails with CLDS_HASH_TABLE_DELETE_NOT_FOUND, then the failure shall be ignored as the value has changed by another operation. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_056: [ For remove value actions, bsi_local_commit_action shall log the metric BSI_LOCAL_VALUE_COUNT with the total count of key value pairs in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_101: [ On success, bsi_local_commit_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_commit_action_frees_resources_for_the_remove_value_action_but_does_not_change_index_if_set_value_happened)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value_2;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n\r\n    // Now another set value comes in which will update the hash table, original commit of remove value should complete without interfering with this\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_2, &replaced_value_2));\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CaptureReturn((LPVOID*)&clds_hazard_pointers_thread);\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete_key_value(kvp_hash_table, IGNORED_ARG, \"key1\", IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread)\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_commit_action(index_update_action_remove_value, test_remove_value_operation_address);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // Can commit the second set value\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value_2, test_set_value_operation_address));\r\n\r\n    BSI_LOCAL_VALUE_HANDLE value;\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_OK, bsi_local_get_value(bsi_local, \"key1\", &value));\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_abort_action */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_063: [ bsi_local_abort_action shall free the resources associated with action. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_064: [ bsi_local_abort_action shall evaluate the type of action that is being aborted. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_065: [ For create block actions, the block id associated with the action shall be deleted from the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_057: [ For create block actions, bsi_local_abort_action shall log the metric BSI_LOCAL_BLOCK_COUNT with the total count of blocks in the index. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_for_create_block_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc());\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create());\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(hash_table, clds_hazard_pointers_thread, \"block1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_024: [ bsi_local_abort_action shall call skipped_seq_no_cb with the sequence number of the action. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_for_create_block_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc());\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create());\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    int64_t seq_no = bsi_local_get_action_seq_no(index_update_action_create_block);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, seq_no));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(hash_table, clds_hazard_pointers_thread, \"block1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_062: [ If action is NULL, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_with_NULL_action_fails)\r\n{\r\n    // arrange\r\n    int result;\r\n\r\n    // act\r\n    result = bsi_local_abort_action(NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_deleting_the_hash_table_item_fails_bsi_abort_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(hash_table, clds_hazard_pointers_thread, \"block1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(CLDS_HASH_TABLE_DELETE_ERROR);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_065: [ For create block actions, the block id associated with the action shall be deleted from the hash table. ]*/\r\nTEST_FUNCTION(when_the_thread_local_hazard_pointers_thread_cannot_be_obtained_bsi_abort_creates_a_new_one)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(hash_table, IGNORED_ARG, \"block1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_registering_a_hazard_pointers_thread_fails_bsi_abort_for_create_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_setting_the_hazard_pointers_thread_in_the_thread_local_storage_slot_fails_bsi_abort_for_create_block_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_create_block);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_066: [ For append actions, the append record shall be removed from the block by calling bsi_local_block_abort_append. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_095: [ The offset passed to bsi_local_block_abort_append shall be obtained from the block append handle obtained in bsi_local_append. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_for_append_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_append(test_bsi_local_block, 0, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_dec_ref(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_024: [ bsi_local_abort_action shall call skipped_seq_no_cb with the sequence number of the action. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_for_append_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append));\r\n    int64_t seq_no = bsi_local_get_action_seq_no(index_update_action_append);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, seq_no));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_append(test_bsi_local_block, 0, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_dec_ref(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_066: [ For append actions, the append record shall be removed from the block by calling bsi_local_block_abort_append. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_095: [ The offset passed to bsi_local_block_abort_append shall be obtained from the block append handle obtained in bsi_local_append. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_abort_passes_the_append_offset_to_delete)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t offset = 42;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_offset(&offset, sizeof(offset));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_append(test_bsi_local_block, 42, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_dec_ref(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_getting_the_append_offset_fails_bsi_local_abort_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_append);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_deleting_the_append_fails_bsi_local_abort_action_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_append(test_bsi_local_block, 0, IGNORED_ARG))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_append);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_067: [ For seal actions, the seal state of the block id associated with the action shall be reset to NOT SEALED by calling bsi_local_block_abort_seal. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_for_seal_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_seal(test_bsi_local_block));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_024: [ bsi_local_abort_action shall call skipped_seq_no_cb with the sequence number of the action. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_for_seal_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    int64_t seq_no = bsi_local_get_action_seq_no(index_update_action_seal);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, seq_no));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_seal(test_bsi_local_block));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_067: [ For seal actions, the seal state of the block id associated with the action shall be reset to NOT SEALED by calling bsi_local_block_abort_seal. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_for_seal_action_allows_a_subsequent_append)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_APPEND_RESULT result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_abort_action(index_update_action_seal));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_append);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_bsi_local_block_abort_seal_fails_bsi_local_abort_action_also_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_seal(test_bsi_local_block))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_seal);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_seal);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_010: [ For remove value actions, the key-value pair associated with the action shall have its state reset to COMMITTED. ] */\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_and_resets_item_for_remove_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_remove_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_04_010: [ For remove value actions, the key-value pair associated with the action shall have its state reset to COMMITTED. ] */\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_and_resets_item_for_remove_value_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_remove_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_048: [ For delete actions, the block associated with the action shall have its state reset to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_and_resets_item_for_delete_block)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_delete_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_048: [ For delete actions, the block associated with the action shall have its state reset to COMMITTED. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_and_resets_item_for_delete_block_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_delete_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // we can again seal the block because the state was reset\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_seal;\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SEAL_RESULT, BSI_LOCAL_SEAL_OK, bsi_local_seal_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_seal));\r\n    (void)bsi_local_abort_action(index_update_action_seal);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_218: [ For set block epoch actions, bsi_local_abort_action shall call bsi_local_block_abort_set_block_epoch and the hash table item referenced by the action shall be released. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_for_set_block_epoch)\r\n{\r\n    // arrange\r\n    BS_OPERATION_ADDRESS_HANDLE previous_operation_address;\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_block_epoch;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_set_block_epoch(bsi_local, \"block1\", 42, &index_update_action_set_block_epoch, &previous_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_set_block_epoch(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_block_epoch);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_184: [ For set value actions: ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_185: [ the value set by the bsi_local_set_value action shall be removed from the hash table. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_058: [ For remove value actions with no replaced value, bsi_local_abort_action shall log the metric BSI_LOCAL_VALUE_COUNT with the total count of key value pairs in the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_061: [ On success, bsi_local_abort_action shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_frees_resources_for_an_aborted_set_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_024: [ bsi_local_abort_action shall call skipped_seq_no_cb with the sequence number of the action. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_for_an_aborted_set_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    int64_t seq_no = bsi_local_get_action_seq_no(index_update_action_set_value);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, seq_no));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_186: [ the replaced value (if any) associated with the action shall be re-inserted in the key-value hash table. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_reinserts_the_replaced_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* replaced_hash_table_item;\r\n    CLDS_HASH_TABLE_ITEM* second_hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&replaced_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&second_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_set_value(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG, NULL, NULL, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value_1);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_277: [ bsi_local_commit_action shall set the state of the value to DELETED so that it is not re-inserted in case of another set value being aborted. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_276: [ If the replace value associated with the action has since been deleted then the replaced value shall be released and ignored. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_does_not_reinsert_the_replaced_value_if_it_is_deleted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_ITEM* replaced_hash_table_item;\r\n    CLDS_HASH_TABLE_ITEM* second_hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // Set value and then remove it\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&replaced_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value_1, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // Set new value\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&second_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &replaced_value));\r\n    // Commmit the remove to go to a DELETED state\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_remove_value, test_set_value_operation_address));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(replaced_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    BSI_LOCAL_VALUE_HANDLE value;\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_GET_VALUE_RESULT, BSI_LOCAL_GET_VALUE_NOT_FOUND, bsi_local_get_value(bsi_local, \"key1\", &value));\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_creating_the_hazard_pointers_thread_handle_fails_bsi_abort_for_set_value_abort_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .SetReturn(NULL);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_clds_hash_table_set_value_fails_bsi_abort_for_set_value_abort_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* replaced_hash_table_item;\r\n    CLDS_HASH_TABLE_ITEM* second_hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &replaced_hash_table_item, NULL, true, 1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_bsi_local_set_value(\"key1\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &second_hash_table_item, test_bsi_local_value, false, 1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &replaced_value));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_set_value(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG, NULL, NULL, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(CLDS_HASH_TABLE_SET_VALUE_ERROR);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value_2);\r\n    (void)bsi_local_abort_action(index_update_action_set_value_1);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_setting_the_hazard_pointers_thread_handle_in_the_TLS_slot_fails_bsi_abort_for_set_value_abort_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .SetReturn(NULL);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(tls_slot, IGNORED_ARG))\r\n        .ValidateArgumentValue_lpTlsValue((LPVOID*)&clds_hazard_pointers_thread)\r\n        .SetReturn(FALSE);\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_unregister_thread(IGNORED_ARG))\r\n        .ValidateArgumentValue_clds_hazard_pointers_thread(&clds_hazard_pointers_thread);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_069: [ If any error occurs while undoing the action, bsi_local_abort_action shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(when_deleting_the_key_fails_bsi_abort_for_set_value_abort_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .SetReturn(CLDS_HASH_TABLE_DELETE_ERROR);\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_024: [ bsi_local_abort_action shall call skipped_seq_no_cb with the sequence number of the action. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_for_a_remove_value_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    int64_t seq_no = bsi_local_get_action_seq_no(index_update_action_remove_value);\r\n    umock_c_reset_all_calls();\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, seq_no));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_remove_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_create_block_aborted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    setup_bsi_local_create_metrics_expectations();\r\n    STRICT_EXPECTED_CALL(mocked_TlsAlloc());\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_create());\r\n    STRICT_EXPECTED_CALL(clds_hash_table_create(IGNORED_ARG, IGNORED_ARG, 1024 * 1024, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table);\r\n    STRICT_EXPECTED_CALL(timer_create_new());\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(hash_table, clds_hazard_pointers_thread, \"block1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_BLOCK_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_create_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_append_action_aborted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    uint64_t append_offset;\r\n\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_find(IGNORED_ARG, IGNORED_ARG, \"block1\"))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*))\r\n        .CaptureReturn(&hash_table_item);\r\n    (void)bsi_local_append(bsi_local, \"block1\", 4 MB, true, 0, &append_offset, &index_update_action_append);\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // Make bsi_local_block_abort_append return the next sequence number\r\n    (void)interlocked_exchange_64(&test_append_sequence_number, expected_next_seq_no - 1);\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_get_offset(test_block_append_1, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_abort_append(test_bsi_local_block, 0, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_block_append_dec_ref(test_block_append_1));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_append);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_delete_block_action_aborted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_block;\r\n    bool was_sealed;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    STRICT_EXPECTED_CALL(timer_get_elapsed_ms(test_timer));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_create_block));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_create_block, test_operation_address));\r\n    umock_c_reset_all_calls();\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", test_incarnation_id, &index_update_action_delete_block, &was_sealed));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_delete_block);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_set_value_action_aborted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_delete(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(azure_messaging_metric_log(metrics[BSI_LOCAL_VALUE_COUNT], 0));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_set_value_action_aborted_with_replaced_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    CLDS_HASH_TABLE_ITEM* second_hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&second_hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id2, &index_update_action_set_value_2, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_set_value(kvp_hash_table, clds_hazard_pointers_thread, \"key1\", IGNORED_ARG, NULL, NULL, IGNORED_ARG, IGNORED_ARG))\r\n        .ValidateArgumentValue_key_AsType(UMOCK_TYPE(char*));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(second_hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_dec_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, expected_next_seq_no));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_set_value_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    (void)bsi_local_abort_action(index_update_action_set_value_1);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_021: [ If the sequence number in the index is incremented as part of the abort operation then bsi_local_abort_action shall call the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no (if any) with that sequence number. ]*/\r\nTEST_FUNCTION(bsi_local_abort_action_calls_skipped_seq_no_cb_when_remove_value_action_aborted)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG))\r\n        .CaptureReturn(&clds_hazard_pointers_thread);\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_create(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG))\r\n        .CaptureReturn(&hash_table_item);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_set_value, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value, test_set_value_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value, &removed_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    int64_t expected_next_seq_no;\r\n    bsi_local_get_next_sequence_no(bsi_local, &expected_next_seq_no);\r\n\r\n    // ignore hash calls\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    // ignore hazard pointers calls\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_acquire(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_release(IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_reclaim(IGNORED_ARG, IGNORED_ARG, IGNORED_ARG)).IgnoreAllCalls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    result = bsi_local_abort_action(index_update_action_remove_value);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_take_snapshot */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_198: [ If bsi_local is NULL then bsi_local_take_snapshot shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_NULL_bsi_local_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(NULL, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_199: [ If snapshot is NULL then bsi_local_take_snapshot shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_NULL_snapshot_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_on_empty_index_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, false, hash_table, kvp_hash_table, 0, 0, maximum_address);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_on_empty_index_without_maximum_address_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n\r\n    expect_take_snapshot(tls_slot, false, hash_table, kvp_hash_table, 0, 0, NULL);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, NULL, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_257: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_258: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_259: [ bsi_local_take_snapshot shall call bsi_local_block_get_allocate_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_263: [ If the block is not cleaned up then bsi_local_take_snapshot shall increment the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_264: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_265: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_266: [ bsi_local_take_snapshot shall call bsi_local_value_get_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_270: [ If the key-value pair is not cleaned up then bsi_local_take_snapshot shall increment the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_blocks_and_5_keys_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    test_fill_index(bsi_local, 5, 5);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, true, hash_table, kvp_hash_table, 5, 5, maximum_address);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_257: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_263: [ If the block is not cleaned up then bsi_local_take_snapshot shall increment the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_264: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_270: [ If the key-value pair is not cleaned up then bsi_local_take_snapshot shall increment the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_blocks_and_5_keys_no_maximum_address_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    test_fill_index(bsi_local, 5, 5);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, true, hash_table, kvp_hash_table, 5, 5, NULL);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, NULL, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_257: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_258: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_259: [ bsi_local_take_snapshot shall call bsi_local_block_get_allocate_operation_address. ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_280: [ If bs_operation_address_compare indicates that the allocate address is greater than maximum_address then bsi_local_take_snapshot shall clean up the block from the array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_263: [ If the block is not cleaned up then bsi_local_take_snapshot shall increment the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_264: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_265: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_266: [ bsi_local_take_snapshot shall call bsi_local_value_get_operation_address. ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_281: [ If bs_operation_address_compare indicates that the set value address is greater than maximum_address then bsi_local_take_snapshot shall clean up the key-value pair from the array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_270: [ If the key-value pair is not cleaned up then bsi_local_take_snapshot shall increment the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_blocks_and_5_keys_filters_out_some_items_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    test_fill_index(bsi_local, 5, 5);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot_with_items_filtered_out(tls_slot, true, hash_table, kvp_hash_table, 5, 0, 2, 5, 0, 3, maximum_address, true);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_257: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_258: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_259: [ bsi_local_take_snapshot shall call bsi_local_block_get_allocate_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_263: [ If the block is not cleaned up then bsi_local_take_snapshot shall increment the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_264: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_265: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_266: [ bsi_local_take_snapshot shall call bsi_local_value_get_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_270: [ If the key-value pair is not cleaned up then bsi_local_take_snapshot shall increment the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_blocks_and_5_keys_with_maximum_all_deleting_not_committed_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    test_fill_index(bsi_local, 5, 5);\r\n\r\n    BSI_LOCAL_ACTION_HANDLE* delete_actions;\r\n    test_delete_items_uncommitted(bsi_local, 5, 5, &delete_actions);\r\n    umock_c_reset_all_calls();\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, true, hash_table, kvp_hash_table, 5, 5, maximum_address);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n\r\n    for (uint32_t i = 0; i < 10; ++i)\r\n    {\r\n        (void)bsi_local_abort_action(delete_actions[i]);\r\n    }\r\n    my_gballoc_free(delete_actions);\r\n\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_200: [ bsi_local_take_snapshot shall allocate memory to hold snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_201: [ bsi_local_take_snapshot shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_202: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_203: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_204: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_205: [ bsi_local_take_snapshot shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_257: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_258: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_259: [ bsi_local_take_snapshot shall call bsi_local_block_get_allocate_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_262: [ If the block state is not COMMITTED or DELETING then bsi_local_take_snapshot shall clean up the block from the array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_263: [ If the block is not cleaned up then bsi_local_take_snapshot shall increment the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_264: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_265: [ If the maximum_address is not NULL then: ]*/\r\n        /* Tests_SRS_BSI_LOCAL_42_266: [ bsi_local_take_snapshot shall call bsi_local_value_get_operation_address. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_269: [ If the key value state is not COMMITTED or DELETING then bsi_local_snapshot_write_to_buffers shall clean up the key-value pair from the array. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_270: [ If the key-value pair is not cleaned up then bsi_local_take_snapshot shall increment the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_254: [ If the maximum_address is not NULL then bsi_local_take_snapshot shall increment the reference count of maximum_address. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_206: [ bsi_local_take_snapshot shall store the arrays and maximum_address in the snapshot. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_208: [ bsi_local_take_snapshot shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_blocks_and_5_keys_with_maximum_second_not_committed_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_create_block_to_abort;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_to_abort;\r\n    test_fill_index_with_second_not_committed(bsi_local, 5, 5, &index_update_action_create_block_to_abort, &index_update_action_set_value_to_abort);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot_with_items_filtered_out(tls_slot, true, hash_table, kvp_hash_table, 5, 1, 1, 5, 1, 1, maximum_address, false);\r\n\r\n    // act\r\n    int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    (void)bsi_local_abort_action(index_update_action_create_block_to_abort);\r\n    (void)bsi_local_abort_action(index_update_action_set_value_to_abort);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_207: [ If there are any errors then bsi_local_take_snapshot shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_on_empty_index_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, false, hash_table, kvp_hash_table, 0, 0, maximum_address);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n            // assert\r\n            ASSERT_ARE_NOT_EQUAL(int, 0, result, \"On failed call %zu\", i);\r\n\r\n            // reset\r\n            TlsSetValue(tls_slot, NULL);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_207: [ If there are any errors then bsi_local_take_snapshot shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_take_snapshot_with_5_block_5_keys_with_maximum_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    test_fill_index(bsi_local, 5, 5);\r\n    umock_c_reset_all_calls();\r\n\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n\r\n    expect_take_snapshot(tls_slot, true, hash_table, kvp_hash_table, 5, 5, maximum_address);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            int result = bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot);\r\n\r\n            // assert\r\n            ASSERT_ARE_NOT_EQUAL(int, 0, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* bsi_local_snapshot_write_to_buffers */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_210: [ If snapshot is NULL then bsi_local_snapshot_write_to_buffers shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_NULL_snapshot_fails)\r\n{\r\n    // arrange\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(NULL, &block_buffers, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_211: [ If local_block_buffers is NULL then bsi_local_snapshot_write_to_buffers shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_NULL_local_block_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 3, 5, 2, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, NULL, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_212: [ If local_value_buffers is NULL then bsi_local_snapshot_write_to_buffers shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_NULL_local_value_buffers_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 3, 5, 2, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_244: [ Otherwise, if there are no blocks then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_empty. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_246: [ Otherwise, if there are no values then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_empty. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_247: [ bsi_local_snapshot_write_to_buffers shall store the block buffer array in local_block_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_248: [ bsi_local_snapshot_write_to_buffers shall store the key-value buffer array in local_value_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_250: [ bsi_local_snapshot_write_to_buffers shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_empty_index_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 0, 0, 0, 0, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n\r\n    STRICT_EXPECTED_CALL(constbuffer_array_create_empty());\r\n    STRICT_EXPECTED_CALL(constbuffer_array_create_empty());\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    ASSERT_IS_NOT_NULL(block_buffers);\r\n    ASSERT_IS_NOT_NULL(value_buffers);\r\n\r\n    uint32_t count;\r\n    (void)real_constbuffer_array_get_buffer_count(block_buffers, &count);\r\n    ASSERT_ARE_EQUAL(uint32_t, 0, count);\r\n    (void)real_constbuffer_array_get_buffer_count(value_buffers, &count);\r\n    ASSERT_ARE_EQUAL(uint32_t, 0, count);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_217: [ If there is at least one block then bsi_local_snapshot_write_to_buffers shall allocate an array of CONSTBUFFER_HANDLE with twice the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_218: [ If there is at least one value then bsi_local_snapshot_write_to_buffers shall allocate an array of CONSTBUFFER_HANDLE with twice the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_219: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_225: [ bsi_local_snapshot_write_to_buffers shall compute the block_id_buffer_size as the string length of the block ID (with terminating NULL) and the fixed field block_id_length. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_226: [ bsi_local_snapshot_write_to_buffers shall allocate the block_id_buffer of size block_id_buffer_size. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_227: [ bsi_local_snapshot_write_to_buffers shall write the block_id_length field to the block_id_buffer with the string length of the block ID (including terminating NULL). ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_228: [ bsi_local_snapshot_write_to_buffers shall copy the block ID (including terminating NULL) to the block_id field of block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_229: [ bsi_local_snapshot_write_to_buffers shall call CONSTBUFFER_CreateWithMoveMemory with block_id_buffer and store it in the next buffer array space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_230: [ bsi_local_snapshot_write_to_buffers shall call bsi_local_block_write_to_buffer with the maximum_address and store the result in the next buffer array space. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_231: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_237: [ bsi_local_snapshot_write_to_buffers shall compute the key_buffer_size as the string length of the key (with terminating NULL) and the fixed field key_length. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_238: [ bsi_local_snapshot_write_to_buffers shall allocate the key_buffer of size key_buffer_size. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_239: [ bsi_local_snapshot_write_to_buffers shall write the key_length field to the key_buffer with the string length of the key (including terminating NULL). ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_240: [ bsi_local_snapshot_write_to_buffers shall copy the key (including terminating NULL) to the key field of key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_241: [ bsi_local_snapshot_write_to_buffers shall call CONSTBUFFER_CreateWithMoveMemory with key_buffer and store it in the next buffer array space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_242: [ bsi_local_snapshot_write_to_buffers shall call bsi_local_value_write_to_buffer and store the result in the next buffer array space. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_243: [ If there is at least one block then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_with_move_buffers with the array of block buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_245: [ If there is at least one value then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_with_move_buffers with the array of key-value pair buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_247: [ bsi_local_snapshot_write_to_buffers shall store the block buffer array in local_block_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_248: [ bsi_local_snapshot_write_to_buffers shall store the key-value buffer array in local_value_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_250: [ bsi_local_snapshot_write_to_buffers shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_5_blocks_and_3_values_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 0, 3, 0, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n    uint32_t block_buffer_count;\r\n    uint32_t value_buffer_count;\r\n    expect_write_snapshot_to_buffers(5, 3, &block_buffer_count, &value_buffer_count, maximum_address);\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    validate_data_written_to_buffers(block_buffers, value_buffers, 0, 5, block_buffer_count, 0, 3, value_buffer_count);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_217: [ If there is at least one block then bsi_local_snapshot_write_to_buffers shall allocate an array of CONSTBUFFER_HANDLE with twice the count of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_218: [ If there is at least one value then bsi_local_snapshot_write_to_buffers shall allocate an array of CONSTBUFFER_HANDLE with twice the count of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_219: [ For each block: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_225: [ bsi_local_snapshot_write_to_buffers shall compute the block_id_buffer_size as the string length of the block ID (with terminating NULL) and the fixed field block_id_length. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_226: [ bsi_local_snapshot_write_to_buffers shall allocate the block_id_buffer of size block_id_buffer_size. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_227: [ bsi_local_snapshot_write_to_buffers shall write the block_id_length field to the block_id_buffer with the string length of the block ID (including terminating NULL). ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_228: [ bsi_local_snapshot_write_to_buffers shall copy the block ID (including terminating NULL) to the block_id field of block_id_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_229: [ bsi_local_snapshot_write_to_buffers shall call CONSTBUFFER_CreateWithMoveMemory with block_id_buffer and store it in the next buffer array space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_230: [ bsi_local_snapshot_write_to_buffers shall call bsi_local_block_write_to_buffer with the maximum_address and store the result in the next buffer array space. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_231: [ For each key-value pair: ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_237: [ bsi_local_snapshot_write_to_buffers shall compute the key_buffer_size as the string length of the key (with terminating NULL) and the fixed field key_length. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_238: [ bsi_local_snapshot_write_to_buffers shall allocate the key_buffer of size key_buffer_size. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_239: [ bsi_local_snapshot_write_to_buffers shall write the key_length field to the key_buffer with the string length of the key (including terminating NULL). ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_240: [ bsi_local_snapshot_write_to_buffers shall copy the key (including terminating NULL) to the key field of key_buffer. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_241: [ bsi_local_snapshot_write_to_buffers shall call CONSTBUFFER_CreateWithMoveMemory with key_buffer and store it in the next buffer array space. ]*/\r\n    /* Tests_SRS_BSI_LOCAL_42_242: [ bsi_local_snapshot_write_to_buffers shall call bsi_local_value_write_to_buffer and store the result in the next buffer array space. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_243: [ If there is at least one block then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_with_move_buffers with the array of block buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_245: [ If there is at least one value then bsi_local_snapshot_write_to_buffers shall call constbuffer_array_create_with_move_buffers with the array of key-value pair buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_247: [ bsi_local_snapshot_write_to_buffers shall store the block buffer array in local_block_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_248: [ bsi_local_snapshot_write_to_buffers shall store the key-value buffer array in local_value_buffers. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_250: [ bsi_local_snapshot_write_to_buffers shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_5_blocks_and_5_values_but_some_filtered_out_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 2, 5, 3, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n    uint32_t block_buffer_count;\r\n    uint32_t value_buffer_count;\r\n    expect_write_snapshot_to_buffers(3, 2, &block_buffer_count, &value_buffer_count, maximum_address);\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    validate_data_written_to_buffers(block_buffers, value_buffers, 2, 3, block_buffer_count, 3, 2, value_buffer_count);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_275: [ If the state of any of the key-value pairs is CREATED then bsi_local_take_snapshot shall replace it with the last committed value. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_value_uncommitted_uses_original_value_succeeds)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    // Write key_0 3 times, only first is committed\r\n    BSI_LOCAL_VALUE_HANDLE local_value_handle_to_create_1 = (BSI_LOCAL_VALUE_HANDLE)0x11111;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_1;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value_1;\r\n    BSI_LOCAL_VALUE_HANDLE local_value_handle_to_create_2 = (BSI_LOCAL_VALUE_HANDLE)0x22222;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value_2;\r\n    BSI_LOCAL_VALUE_HANDLE local_value_handle_to_create_3 = (BSI_LOCAL_VALUE_HANDLE)0x33333;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_set_value_3;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value_3;\r\n\r\n    CLDS_HAZARD_POINTERS_THREAD_HANDLE clds_hazard_pointers_thread;\r\n    CLDS_HASH_TABLE_ITEM* hash_table_item;\r\n\r\n    expect_bsi_local_set_value_override_local_value(\"key_0\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item, NULL, true, 1, local_value_handle_to_create_1);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key_0\", test_incarnation_id, &index_update_action_set_value_1, &replaced_value_1));\r\n    ASSERT_IS_NULL(replaced_value_1);\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_value_set_operation_address(local_value_handle_to_create_1, (BS_OPERATION_ADDRESS_HANDLE)((size_t)test_set_value_operation_address + 1000 + 1)));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(hash_table_item));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_set_value_1, (BS_OPERATION_ADDRESS_HANDLE)((size_t)test_set_value_operation_address + 1000 + 1)));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    expect_bsi_local_set_value_override_local_value(\"key_0\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item, local_value_handle_to_create_1, false, 1, local_value_handle_to_create_2);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key_0\", test_incarnation_id, &index_update_action_set_value_2, &replaced_value_2));\r\n    ASSERT_IS_NOT_NULL(replaced_value_2);\r\n    ASSERT_ARE_EQUAL(void_ptr, local_value_handle_to_create_1, replaced_value_2);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    expect_bsi_local_set_value_override_local_value(\"key_0\", NULL, tls_slot, kvp_hash_table, &clds_hazard_pointers_thread, &hash_table_item, local_value_handle_to_create_2, false, 1, local_value_handle_to_create_3);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key_0\", test_incarnation_id, &index_update_action_set_value_3, &replaced_value_3));\r\n    ASSERT_IS_NOT_NULL(replaced_value_3);\r\n    ASSERT_ARE_EQUAL(void_ptr, local_value_handle_to_create_2, replaced_value_3);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // Snapshot\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(tls_slot))\r\n        .CallCannotFail();\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(kvp_hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n\r\n    // Skipping over the non-committed values\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_inc_ref(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n\r\n    ASSERT_IS_TRUE(test_operation_address_array_count < MAX_OPERATION_ADDRESS_ARRAY_SIZE, \"Increase MAX_OPERATION_ADDRESS_ARRAY_SIZE for test\");\r\n    test_operation_address_array[test_operation_address_array_count] = create_test_bs_operation_address(1);\r\n\r\n    STRICT_EXPECTED_CALL(bsi_local_value_get_operation_address(local_value_handle_to_create_1, IGNORED_ARG))\r\n        .CopyOutArgumentBuffer_operation_address(&test_operation_address_array[test_operation_address_array_count], sizeof(test_operation_address_array[test_operation_address_array_count]));\r\n    STRICT_EXPECTED_CALL(bs_operation_address_compare(test_operation_address_array[test_operation_address_array_count], maximum_address));\r\n    STRICT_EXPECTED_CALL(bs_operation_address_dec_ref(test_operation_address_array[test_operation_address_array_count]));\r\n\r\n    test_operation_address_array_count++;\r\n\r\n    STRICT_EXPECTED_CALL(bs_operation_address_inc_ref(maximum_address));\r\n\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_take_snapshot(bsi_local, maximum_address, &snapshot));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    umock_c_reset_all_calls();\r\n\r\n    // Write to buffers (make sure we use the old value that was committed)\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n\r\n    STRICT_EXPECTED_CALL(malloc(sizeof(CONSTBUFFER_HANDLE) * 2));\r\n    uint32_t expected_size = sizeof(uint16_t) + 6 /*strlen(key_X)*/;\r\n    STRICT_EXPECTED_CALL(malloc(expected_size));\r\n    STRICT_EXPECTED_CALL(write_uint16_t(IGNORED_ARG, 6));\r\n    STRICT_EXPECTED_CALL(CONSTBUFFER_CreateWithMoveMemory(IGNORED_ARG, expected_size));\r\n    STRICT_EXPECTED_CALL(bsi_local_value_write_to_buffer(local_value_handle_to_create_1));\r\n\r\n    STRICT_EXPECTED_CALL(constbuffer_array_create_empty());\r\n    STRICT_EXPECTED_CALL(constbuffer_array_create_with_move_buffers(IGNORED_ARG, 2));\r\n\r\n    // act\r\n    int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    validate_data_written_to_buffers(block_buffers, value_buffers, 0, 0, 0, 0, 1, 2);\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_abort_action(index_update_action_set_value_2);\r\n    bsi_local_abort_action(index_update_action_set_value_3);\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_249: [ If there are any errors then bsi_local_snapshot_write_to_buffers shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_snapshot_write_to_buffers_with_5_blocks_and_3_values_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 0, 3, 0, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n    uint32_t block_buffer_count;\r\n    uint32_t value_buffer_count;\r\n    expect_write_snapshot_to_buffers(5, 3, &block_buffer_count, &value_buffer_count, maximum_address);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            int result = bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers);\r\n\r\n            // assert\r\n            ASSERT_ARE_NOT_EQUAL(int, 0, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_snapshot_free(snapshot);\r\n    bsi_local_destroy(bsi_local);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* bsi_local_snapshot_free */\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_251: [ If snapshot is NULL then bsi_local_free_snapshot shall return. ]*/\r\nTEST_FUNCTION(bsi_local_free_snapshot_with_NULL_snapshot_returns)\r\n{\r\n    // arrange\r\n\r\n    // act\r\n    bsi_local_snapshot_free(NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_252: [ bsi_local_free_snapshot shall free all of the copied array data from the hash tables. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_253: [ bsi_local_free_snapshot shall free the snapshot. ]*/\r\nTEST_FUNCTION(bsi_local_free_snapshot_frees_resources)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 0, 3, 0, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n    uint32_t block_buffer_count;\r\n    uint32_t value_buffer_count;\r\n    expect_write_snapshot_to_buffers(5, 3, &block_buffer_count, &value_buffer_count, maximum_address);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    STRICT_EXPECTED_CALL(bs_operation_address_dec_ref(maximum_address));\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    for (uint32_t i = 0; i < 5; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    bsi_local_snapshot_free(snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_252: [ bsi_local_free_snapshot shall free all of the copied array data from the hash tables. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_253: [ bsi_local_free_snapshot shall free the snapshot. ]*/\r\nTEST_FUNCTION(bsi_local_free_snapshot_frees_resources_after_filtering_some_items)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n\r\n    BS_OPERATION_ADDRESS_HANDLE maximum_address = create_test_bs_operation_address(42);\r\n    BSI_LOCAL_SNAPSHOT_HANDLE snapshot = test_take_snapshot_and_filter(bsi_local, tls_slot, hash_table, kvp_hash_table, 5, 2, 5, 3, maximum_address);\r\n\r\n    CONSTBUFFER_ARRAY_HANDLE block_buffers;\r\n    CONSTBUFFER_ARRAY_HANDLE value_buffers;\r\n    uint32_t block_buffer_count;\r\n    uint32_t value_buffer_count;\r\n    expect_write_snapshot_to_buffers(3, 2, &block_buffer_count, &value_buffer_count, maximum_address);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_snapshot_write_to_buffers(snapshot, &block_buffers, &value_buffers));\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    STRICT_EXPECTED_CALL(bs_operation_address_dec_ref(maximum_address));\r\n    for (uint32_t i = 0; i < 2; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    for (uint32_t i = 0; i < 3; ++i)\r\n    {\r\n        STRICT_EXPECTED_CALL(clds_hash_table_node_release(IGNORED_ARG));\r\n    }\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    bsi_local_snapshot_free(snapshot);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_constbuffer_array_dec_ref(block_buffers);\r\n    real_constbuffer_array_dec_ref(value_buffers);\r\n    hook_bs_operation_address_dec_ref(maximum_address);\r\n}\r\n\r\n/* index_block_id_key_hash */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_082: [ index_block_id_key_hash shall return the hash of a block Id by calling hash_compute_hash with the buffer being key and the length being the string length of key. ]*/\r\nTEST_FUNCTION(index_block_id_key_hash_calls_hash_compute_hash_to_get_the_hash_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    uint64_t result;\r\n    uint32_t hash = 0x42;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(\"block1\", strlen(\"block1\"), IGNORED_ARG))\r\n        .ValidateArgumentValue_buffer_AsType(UMOCK_TYPE(char*))\r\n        .CopyOutArgumentBuffer_hash(&hash, sizeof(hash));\r\n\r\n    // act\r\n    result = saved_compute_hash(\"block1\");\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(uint64_t, 0x42, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_090: [ If hash_compute_hash fails, index_block_id_key_hash shall return 0. ]*/\r\nTEST_FUNCTION(when_the_underlying_hash_computation_fails_index_block_id_key_hash_returns_0)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    uint64_t result;\r\n    uint32_t hash = 0x42;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(hash_compute_hash(\"block1\", strlen(\"block1\"), IGNORED_ARG))\r\n        .ValidateArgumentValue_buffer_AsType(UMOCK_TYPE(char*))\r\n        .CopyOutArgumentBuffer_hash(&hash, sizeof(hash))\r\n        .SetReturn(1);\r\n\r\n    // act\r\n    result = saved_compute_hash(\"block1\");\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(uint64_t, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* index_block_id_key_compare */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_083: [ index_block_id_key_compare shall compare the 2 keys as strings. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_084: [ If key_1 is less than key_2 per a strcmp comparison, index_block_id_key_compare shall return a negative value. ]*/\r\nTEST_FUNCTION(key_compare_func_with_key1_less_than_key2_returns_a_negative_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = saved_key_compare_func(\"a\", \"b\");\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_TRUE(result < 0);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_083: [ index_block_id_key_compare shall compare the 2 keys as strings. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_086: [ If key_1 is equal to key_2 per a strcmp comparison, index_block_id_key_compare shall return 0. ]*/\r\nTEST_FUNCTION(key_compare_func_with_key1_equal_to_key2_returns_0)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = saved_key_compare_func(\"a\", \"a\");\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_083: [ index_block_id_key_compare shall compare the 2 keys as strings. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_085: [ If key_1 is greater than key_2 per a strcmp comparison, index_block_id_key_compare shall return a positive value. ]*/\r\nTEST_FUNCTION(key_compare_func_with_key1_greater_than_key2_returns_a_positive_value)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = saved_key_compare_func(\"a\", \"b\");\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_TRUE(result < 0);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_get_action_seq_no */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_returns_0_for_the_first_update_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    int64_t result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block_x\", test_incarnation_id, 4 MB, &index_update_action));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_get_action_seq_no(index_update_action);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, 0, result);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_117: [ The current sequence number maintained by the index shall be assigned to the index update action and the current sequence number shall also be incremented so that the next update receives the next value. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_create_block_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block_1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block_2\", test_incarnation_id2, 4 MB, &index_update_action_2));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action_1);\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, 0, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 1, result_2);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_1);\r\n    bsi_local_abort_action(index_update_action_2);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_122: [ If action is NULL bsi_local_get_action_seq_no shall return -1. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_with_NULL_action_fails)\r\n{\r\n    // arrange\r\n    int64_t result;\r\n\r\n    // act\r\n    result = bsi_local_get_action_seq_no(NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, -1, result);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_118: [ A sequence number shall be assigned to the action and the sequence number maintained by the index incremented. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_append_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_append_2;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    int64_t result_3;\r\n    uint64_t append_offset;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    // act\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action));\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action, test_operation_address));\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append_1));\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_append_1);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_append_1, test_operation_address));\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_APPEND_RESULT, BSI_LOCAL_APPEND_OK, bsi_local_append(bsi_local, \"block1\", 1 MB, true, 0, &append_offset, &index_update_action_append_2));\r\n    result_3 = bsi_local_get_action_seq_no(index_update_action_append_2);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_append_2, test_operation_address));\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int64_t, 0, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 1, result_2);\r\n    ASSERT_ARE_EQUAL(int64_t, 2, result_3);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_120: [ A sequence number shall be assigned to the action and the sequence number maintained by the index incremented. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_delete_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_delete_2;\r\n    bool was_sealed;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    int64_t result_3;\r\n    int64_t result_4;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n\r\n    // act\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action_1));\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action_1);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block1\", NULL, &index_update_action_delete_1, &was_sealed));\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_delete_1);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_delete_1, test_remove_value_operation_address));\r\n    // Extra sequence number during commit\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_CREATE_BLOCK_RESULT, BSI_LOCAL_CREATE_BLOCK_OK, bsi_local_create_block(bsi_local, \"block2\", test_incarnation_id2, 4 MB, &index_update_action_2));\r\n    result_3 = bsi_local_get_action_seq_no(index_update_action_2);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_2, test_operation_address));\r\n\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_DELETE_RESULT, BSI_LOCAL_DELETE_OK, bsi_local_delete_block(bsi_local, \"block2\", NULL, &index_update_action_delete_2, &was_sealed));\r\n    result_4 = bsi_local_get_action_seq_no(index_update_action_delete_2);\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_delete_2, test_remove_value_operation_address));\r\n    // Extra sequence number during commit\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int64_t, 0, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 1, result_2);\r\n    ASSERT_ARE_EQUAL(int64_t, 3, result_3);\r\n    ASSERT_ARE_EQUAL(int64_t, 4, result_4);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_158: [ A sequence number shall be assigned to the action and the sequence number maintained by the index incremented. ]*/\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_set_value_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_1, &replaced_value));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key2\", test_incarnation_id2, &index_update_action_2, &replaced_value));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action_1);\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, 0, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 1, result_2);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_2);\r\n    bsi_local_abort_action(index_update_action_1);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_007: [ A sequence number shall be assigned to the action and the sequence number maintained by the index incremented. ] */\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_remove_value_action)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value1;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value2;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_1, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key2\", test_incarnation_id2, &index_update_action_2, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_2, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", NULL, NULL, &index_update_action_remove_value1, &removed_value1));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key2\", NULL, NULL, &index_update_action_remove_value2, &removed_value2));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action_remove_value1);\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_remove_value2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, 2, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 3, result_2);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_remove_value1);\r\n    bsi_local_abort_action(index_update_action_remove_value2);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_121: [ On success, bsi_local_get_action_seq_no shall return a value greater or equal to zero that represents the associated sequence number of the index update. ]*/\r\n/* Tests_SRS_BSI_LOCAL_04_007: [ A sequence number shall be assigned to the action and the sequence number maintained by the index incremented. ] */\r\nTEST_FUNCTION(bsi_local_get_action_seq_no_increments_with_each_remove_value_action_with_incarnation_id)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_2;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value1;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action_remove_value2;\r\n    BSI_LOCAL_VALUE_HANDLE replaced_value;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value1;\r\n    BSI_LOCAL_VALUE_HANDLE removed_value2;\r\n    int64_t result_1;\r\n    int64_t result_2;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key1\", test_incarnation_id, &index_update_action_1, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_1, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_SET_VALUE_RESULT, BSI_LOCAL_SET_VALUE_OK, bsi_local_set_value(bsi_local, \"key2\", test_incarnation_id2, &index_update_action_2, &replaced_value));\r\n    ASSERT_ARE_EQUAL(int, 0, bsi_local_commit_action(index_update_action_2, test_operation_address));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key1\", test_incarnation_id, NULL, &index_update_action_remove_value1, &removed_value1));\r\n    ASSERT_ARE_EQUAL(BSI_LOCAL_REMOVE_VALUE_RESULT, BSI_LOCAL_REMOVE_VALUE_OK, bsi_local_remove_value(bsi_local, \"key2\", test_incarnation_id, NULL, &index_update_action_remove_value2, &removed_value2));\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result_1 = bsi_local_get_action_seq_no(index_update_action_remove_value1);\r\n    result_2 = bsi_local_get_action_seq_no(index_update_action_remove_value2);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_ARE_EQUAL(int64_t, 2, result_1);\r\n    ASSERT_ARE_EQUAL(int64_t, 3, result_2);\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action_remove_value1);\r\n    bsi_local_abort_action(index_update_action_remove_value2);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_subscribe_skipped_seq_no */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_124: [ bsi_local_subscribe_skipped_seq_no shall subscribe for notifications of skipped (unused) sequence numbers generated by conflicts in updating the index. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_125: [ On success, bsi_local_subscribe_skipped_seq_no shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_126: [ If bsi_local is NULL, bsi_local_subscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    int result;\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(NULL, test_skipped_seq_no_cb, (void*)0x5000);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_127: [ If skipped_seq_no_cb is NULL, bsi_local_subscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_with_NULL_skipped_seq_no_cb_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(bsi_local, NULL, (void*)0x5000);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_128: [ skipped_seq_no_cb_context shall be allowed to be NULL. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_with_NULL_skipped_seq_no_cb_context_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_129: [ If bsi_local_subscribe_skipped_seq_no was already called and a subcription already exists, bsi_local_subscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_after_bsi_local_subscribe_skipped_seq_no_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_129: [ If bsi_local_subscribe_skipped_seq_no was already called and a subcription already exists, bsi_local_subscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_subscribe_skipped_seq_no_after_unsubscribe_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    (void)bsi_local_unsubscribe_skipped_seq_no(bsi_local);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_unsubscribe_skipped_seq_no */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_130: [ bsi_local_unsubscribe_skipped_seq_no shall clear the skipped sequence numbers notification subcription. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_131: [ On success it shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_unsubscribe_skipped_seq_no_succeeds)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_unsubscribe_skipped_seq_no(bsi_local);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_132: [ If bsi_local is NULL, bsi_local_unsubscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_unsubscribe_skipped_seq_no_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    int result;\r\n\r\n    // act\r\n    result = bsi_local_unsubscribe_skipped_seq_no(NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_133: [ If no subscription was previously made, bsi_local_unsubscribe_skipped_seq_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_unsubscribe_skipped_seq_no_when_not_subscribed_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_unsubscribe_skipped_seq_no(bsi_local);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* bsi_local_get_next_sequence_no */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_138: [ bsi_local_get_next_sequence_no shall return in next_sequence_no the next sequence number value that will be assigned by the bsi_local object. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_139: [ On success, bsi_local_get_next_sequence_no shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_next_sequence_no_returns_the_next_sequence_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    int64_t next_sequence_no = 0xFF;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_get_next_sequence_no(bsi_local, &next_sequence_no);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(int64_t, 0, next_sequence_no);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_140: [ If bsi_local is NULL, bsi_local_get_next_sequence_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_next_sequence_no_with_NULL_bsi_fails)\r\n{\r\n    // arrange\r\n    int result;\r\n    int64_t next_sequence_no = 0xFF;\r\n\r\n    // act\r\n    result = bsi_local_get_next_sequence_no(NULL, &next_sequence_no);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_141: [ If next_sequence_no is NULL, bsi_local_get_next_sequence_no shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_next_sequence_no_with_NULL_next_sequence_no_fails)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_get_next_sequence_no(bsi_local, NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_138: [ bsi_local_get_next_sequence_no shall return in next_sequence_no the next sequence number value that will be assigned by the bsi_local object. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_139: [ On success, bsi_local_get_next_sequence_no shall return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_next_sequence_no_after_one_operation_happened_returns_the_correct_next_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    int result;\r\n    int64_t next_sequence_no = 0xFF;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    result = bsi_local_get_next_sequence_no(bsi_local, &next_sequence_no);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(int64_t, 1, next_sequence_no);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* on_skipped_seq_no */\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_134: [ If context is NULL, on_skipped_seq_no shall return. ]*/\r\nTEST_FUNCTION(on_hash_table_skipped_seq_no_with_NULL_context_returns)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    saved_hash_table_skipped_seq_no_cb[0](NULL, 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_135: [ context shall be used as a BSI_LOCAL_HANDLE. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_136: [ The skipped sequence number shall be indicated by call to the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no. ]*/\r\nTEST_FUNCTION(on_hash_table_skipped_seq_no_indicates_the_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x5000, 0x42));\r\n\r\n    // act\r\n    saved_hash_table_skipped_seq_no_cb[0](saved_hash_table_skipped_seq_no_cb_context[0], 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_135: [ context shall be used as a BSI_LOCAL_HANDLE. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_136: [ The skipped sequence number shall be indicated by call to the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no. ]*/\r\nTEST_FUNCTION(on_hash_table_skipped_seq_no_indicates_2_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, 4246));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, 43));\r\n\r\n    // act\r\n    saved_hash_table_skipped_seq_no_cb[0](saved_hash_table_skipped_seq_no_cb_context[0], 4246);\r\n    saved_hash_table_skipped_seq_no_cb[0](saved_hash_table_skipped_seq_no_cb_context[0], 43);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_137: [ If no subscription for the skipped sequence numbers has been made, on_skipped_seq_no shall return. ]*/\r\nTEST_FUNCTION(on_hash_table_skipped_seq_no_without_a_subscription_does_not_indicates_the_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    saved_hash_table_skipped_seq_no_cb[0](saved_hash_table_skipped_seq_no_cb_context[0], 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_134: [ If context is NULL, on_skipped_seq_no shall return. ]*/\r\nTEST_FUNCTION(on_bsi_local_block_skipped_seq_no_with_NULL_context_returns)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    saved_bsi_local_block_skipped_seq_no_cb(NULL, 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_135: [ context shall be used as a BSI_LOCAL_HANDLE. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_136: [ The skipped sequence number shall be indicated by call to the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no. ]*/\r\nTEST_FUNCTION(on_bsi_local_block_skipped_seq_no_indicates_the_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x5000);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x5000, 0x42));\r\n\r\n    // act\r\n    saved_bsi_local_block_skipped_seq_no_cb(saved_bsi_local_block_skipped_seq_no_cb_context, 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_135: [ context shall be used as a BSI_LOCAL_HANDLE. ]*/\r\n/* Tests_SRS_BSI_LOCAL_01_136: [ The skipped sequence number shall be indicated by call to the skipped_seq_no_cb passed to bsi_local_subscribe_skipped_seq_no. ]*/\r\nTEST_FUNCTION(on_bsi_local_block_skipped_seq_no_indicates_2_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_subscribe_skipped_seq_no(bsi_local, test_skipped_seq_no_cb, (void*)0x6000);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, 4246));\r\n    STRICT_EXPECTED_CALL(test_skipped_seq_no_cb((void*)0x6000, 43));\r\n\r\n    // act\r\n    saved_bsi_local_block_skipped_seq_no_cb(saved_bsi_local_block_skipped_seq_no_cb_context, 4246);\r\n    saved_bsi_local_block_skipped_seq_no_cb(saved_bsi_local_block_skipped_seq_no_cb_context, 43);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_01_137: [ If no subscription for the skipped sequence numbers has been made, on_skipped_seq_no shall return. ]*/\r\nTEST_FUNCTION(on_bsi_local_block_skipped_seq_no_without_a_subscription_does_not_indicates_the_skipped_seq_no)\r\n{\r\n    // arrange\r\n    BSI_LOCAL_HANDLE bsi_local;\r\n    BSI_LOCAL_ACTION_HANDLE index_update_action;\r\n    bsi_local = bsi_local_create(test_metric_context, &test_sequence_number);\r\n    (void)bsi_local_create_block(bsi_local, \"block1\", test_incarnation_id, 4 MB, &index_update_action);\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    saved_bsi_local_block_skipped_seq_no_cb(saved_bsi_local_block_skipped_seq_no_cb_context, 0x42);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_abort_action(index_update_action);\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n//\r\n// bsi_local_get_block_list\r\n//\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_169: [ If bsi_local is NULL then bsi_local_get_block_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_NULL_bsi_local_fails)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(NULL, \"block\", &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_170: [ If block_list is NULL then bsi_local_get_block_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_NULL_block_list_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, \"block\", NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_172: [ bsi_local_get_block_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_173: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_174: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_175: [ bsi_local_get_block_list shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_176: [ bsi_local_get_block_list shall iterate over the array of blocks and count the number with a block ID that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_177: [ bsi_local_get_block_list shall call rc_string_array_create with the count of block ID's that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_178: [ bsi_local_get_block_list shall copy the block ID of each block if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_179: [ bsi_local_get_block_list shall store the array in block_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_180: [ bsi_local_get_block_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_0_blocks_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(rc_string_array_create(0));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, \"block\", &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(block_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 0, block_list->count);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(block_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_172: [ bsi_local_get_block_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_175: [ bsi_local_get_block_list shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_176: [ bsi_local_get_block_list shall iterate over the array of blocks and count the number with a block ID that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_177: [ bsi_local_get_block_list shall call rc_string_array_create with the count of block ID's that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_178: [ bsi_local_get_block_list shall copy the block ID of each block if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_179: [ bsi_local_get_block_list shall store the array in block_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_180: [ bsi_local_get_block_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_10_blocks_matching_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(hash_table, 10, 10);\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, \"block\", &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(block_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, block_list->count);\r\n\r\n    bool found[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        found[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < block_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found[j], \"should only find each block once in list\");\r\n                found[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(block_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_171: [ prefix may be NULL. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_10_blocks_NULL_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(hash_table, 10, 10);\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, NULL, &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(block_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, block_list->count);\r\n\r\n    bool found[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        found[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < block_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found[j], \"should only find each block once in list\");\r\n                found[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(block_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_172: [ bsi_local_get_block_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_175: [ bsi_local_get_block_list shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_176: [ bsi_local_get_block_list shall iterate over the array of blocks and count the number with a block ID that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_177: [ bsi_local_get_block_list shall call rc_string_array_create with the count of block ID's that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_178: [ bsi_local_get_block_list shall copy the block ID of each block if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_179: [ bsi_local_get_block_list shall store the array in block_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_180: [ bsi_local_get_block_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_10_blocks_matching_prefix_11_not_matching_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_block\", 10, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 11, \"not_matching\", 0, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_other_block\", 0, \"\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(hash_table, 10, 21);\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, \"my\", &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(block_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, block_list->count);\r\n\r\n    bool found_1[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        found_1[i] = false;\r\n    }\r\n    bool found_2[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        found_2[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < block_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_1); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"my_block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_1[j], \"should only find each block once in list\");\r\n                found_1[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_2); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"my_other_block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_2[j], \"should only find each block once in list\");\r\n                found_2[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_1[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_2[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(block_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_172: [ bsi_local_get_block_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_175: [ bsi_local_get_block_list shall call clds_hash_table_snapshot on the block hash table to get the array of blocks. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_176: [ bsi_local_get_block_list shall iterate over the array of blocks and count the number with a block ID that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_177: [ bsi_local_get_block_list shall call rc_string_array_create with the count of block ID's that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_178: [ bsi_local_get_block_list shall copy the block ID of each block if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_179: [ bsi_local_get_block_list shall store the array in block_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_180: [ bsi_local_get_block_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_20_blocks_empty_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_block\", 10, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 10, \"other_prefix\", 0, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_other_block\", 0, \"\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(hash_table, 20, 20);\r\n\r\n    // act\r\n    int result = bsi_local_get_block_list(bsi_local, \"\", &block_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(block_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 20, block_list->count);\r\n\r\n    bool found_1[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        found_1[i] = false;\r\n    }\r\n    bool found_2[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        found_2[i] = false;\r\n    }\r\n    bool found_3[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_3); ++i)\r\n    {\r\n        found_3[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < block_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_1); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"my_block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_1[j], \"should only find each block once in list\");\r\n                found_1[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_2); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"my_other_block_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_2[j], \"should only find each block once in list\");\r\n                found_2[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_3); ++j)\r\n        {\r\n            char block_id[32];\r\n            (void)sprintf(block_id, \"other_prefix_%\" PRIu32, j);\r\n            if (strcmp(block_id, block_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_3[j], \"should only find each block once in list\");\r\n                found_3[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_1[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_2[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_3); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_3[i], \"should find each block in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(block_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_181: [ If there are any failures then bsi_local_get_block_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_block_list_with_10_blocks_matching_prefix_11_not_matching_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* block_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_block\", 10, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 11, \"not_matching\", 0, \"key\");\r\n    test_fill_index_with_prefix(bsi_local, 5, \"my_other_block\", 0, \"\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(hash_table, 10, 21);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            int result = bsi_local_get_block_list(bsi_local, \"my\", &block_list);\r\n\r\n            // assert\r\n            ASSERT_ARE_NOT_EQUAL(int, 0, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n//\r\n// bsi_local_get_key_list\r\n//\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_182: [ If bsi_local is NULL then bsi_local_get_key_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_NULL_bsi_local_fails)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(NULL, \"key\", &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_183: [ If key_list is NULL then bsi_local_get_key_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_NULL_key_list_fails)\r\n{\r\n    // arrange\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, \"key\", NULL);\r\n\r\n    // assert\r\n    ASSERT_ARE_NOT_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_185: [ bsi_local_get_key_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_186: [ If no hazard pointers thread handle exists in the thread local storage a new one shall be created. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_187: [ The newly created hazard pointers thread handle shall be stored in the thread local storage slot by using TlsSetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_188: [ bsi_local_get_key_list shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_189: [ bsi_local_get_key_list shall iterate over the array of key-value pairs and count the number with a key that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_190: [ bsi_local_get_key_list shall call rc_string_array_create with the count of keys that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_191: [ bsi_local_get_key_list shall copy the key of each key-value pair if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_192: [ bsi_local_get_key_list shall store the array in key_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_193: [ bsi_local_get_key_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_0_keys_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    umock_c_reset_all_calls();\r\n\r\n    STRICT_EXPECTED_CALL(mocked_TlsGetValue(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hazard_pointers_register_thread(IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(mocked_TlsSetValue(IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(clds_hash_table_snapshot(kvp_hash_table, IGNORED_ARG, IGNORED_ARG, IGNORED_ARG));\r\n    STRICT_EXPECTED_CALL(rc_string_array_create(0));\r\n\r\n    STRICT_EXPECTED_CALL(free(IGNORED_ARG));\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, \"key\", &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(key_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 0, key_list->count);\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(key_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_185: [ bsi_local_get_key_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_188: [ bsi_local_get_key_list shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_189: [ bsi_local_get_key_list shall iterate over the array of key-value pairs and count the number with a key that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_190: [ bsi_local_get_key_list shall call rc_string_array_create with the count of keys that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_191: [ bsi_local_get_key_list shall copy the key of each key-value pair if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_192: [ bsi_local_get_key_list shall store the array in key_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_193: [ bsi_local_get_key_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_10_keys_matching_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(kvp_hash_table, 10, 10);\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, \"key\", &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(key_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, key_list->count);\r\n\r\n    bool found[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        found[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < key_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found[j], \"should only find each key once in list\");\r\n                found[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(key_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_184: [ prefix may be NULL. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_10_keys_NULL_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 10, \"block\", 10, \"key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(kvp_hash_table, 10, 10);\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, NULL, &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(key_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, key_list->count);\r\n\r\n    bool found[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        found[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < key_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found[j], \"should only find each key once in list\");\r\n                found[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(key_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_185: [ bsi_local_get_key_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_188: [ bsi_local_get_key_list shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_189: [ bsi_local_get_key_list shall iterate over the array of key-value pairs and count the number with a key that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_190: [ bsi_local_get_key_list shall call rc_string_array_create with the count of keys that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_191: [ bsi_local_get_key_list shall copy the key of each key-value pair if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_192: [ bsi_local_get_key_list shall store the array in key_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_193: [ bsi_local_get_key_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_20_keys_matching_prefix_11_not_matching_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 1, \"my_block\", 5, \"my_key\");\r\n    test_fill_index_with_prefix(bsi_local, 3, \"not_matching\", 11, \"not_matching\");\r\n    test_fill_index_with_prefix(bsi_local, 7, \"my_other_block\", 5, \"my_other_key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(kvp_hash_table, 10, 21);\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, \"my\", &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(key_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 10, key_list->count);\r\n\r\n    bool found_1[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        found_1[i] = false;\r\n    }\r\n    bool found_2[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        found_2[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < key_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_1); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"my_key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_1[j], \"should only find each key once in list\");\r\n                found_1[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_2); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"my_other_key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_2[j], \"should only find each key once in list\");\r\n                found_2[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_1[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_2[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(key_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_185: [ bsi_local_get_key_list shall get the hazard pointers thread from the thread local storage slot allocated in bsi_local_create by using TlsGetValue. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_188: [ bsi_local_get_key_list shall call clds_hash_table_snapshot on the key-value pair hash table to get the array of key-value pairs. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_189: [ bsi_local_get_key_list shall iterate over the array of key-value pairs and count the number with a key that starts with prefix (or all if prefix is NULL or empty string). ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_190: [ bsi_local_get_key_list shall call rc_string_array_create with the count of keys that matched prefix. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_191: [ bsi_local_get_key_list shall copy the key of each key-value pair if it starts with prefix (or prefix is NULL or empty string) by calling rc_string_create. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_192: [ bsi_local_get_key_list shall store the array in key_list. ]*/\r\n/* Tests_SRS_BSI_LOCAL_42_193: [ bsi_local_get_key_list shall succeed and return 0. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_20_keys_empty_prefix_succeeds)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 7, \"my_block\", 5, \"my_key\");\r\n    test_fill_index_with_prefix(bsi_local, 1, \"other_prefix\", 10, \"other_key\");\r\n    test_fill_index_with_prefix(bsi_local, 1, \"my_other_block\", 5, \"my_other_key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(kvp_hash_table, 20, 20);\r\n\r\n    // act\r\n    int result = bsi_local_get_key_list(bsi_local, \"\", &key_list);\r\n\r\n    // assert\r\n    ASSERT_ARE_EQUAL(int, 0, result);\r\n    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());\r\n    ASSERT_IS_NOT_NULL(key_list);\r\n    ASSERT_ARE_EQUAL(uint32_t, 20, key_list->count);\r\n\r\n    bool found_1[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        found_1[i] = false;\r\n    }\r\n    bool found_2[5];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        found_2[i] = false;\r\n    }\r\n    bool found_3[10];\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_3); ++i)\r\n    {\r\n        found_3[i] = false;\r\n    }\r\n\r\n    for (uint32_t i = 0; i < key_list->count; ++i)\r\n    {\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_1); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"my_key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_1[j], \"should only find each key once in list\");\r\n                found_1[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_2); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"my_other_key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_2[j], \"should only find each key once in list\");\r\n                found_2[j] = true;\r\n                break;\r\n            }\r\n        }\r\n        for (uint32_t j = 0; j < MU_COUNT_ARRAY_ITEMS(found_3); ++j)\r\n        {\r\n            char key[32];\r\n            (void)sprintf(key, \"other_key_%\" PRIu32, j);\r\n            if (strcmp(key, key_list->string_array[i]->string) == 0)\r\n            {\r\n                ASSERT_IS_FALSE(found_3[j], \"should only find each key once in list\");\r\n                found_3[j] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_1); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_1[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_2); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_2[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n    for (uint32_t i = 0; i < MU_COUNT_ARRAY_ITEMS(found_3); ++i)\r\n    {\r\n        ASSERT_IS_TRUE(found_3[i], \"should find each key in list, did not find %\" PRIu32, i);\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n    real_rc_string_array_destroy(key_list);\r\n}\r\n\r\n/* Tests_SRS_BSI_LOCAL_42_194: [ If there are any failures then bsi_local_get_key_list shall fail and return a non-zero value. ]*/\r\nTEST_FUNCTION(bsi_local_get_key_list_with_10_keys_matching_prefix_11_not_matching_fails_when_underlying_functions_fail)\r\n{\r\n    // arrange\r\n    RC_STRING_ARRAY* key_list = NULL;\r\n    DWORD tls_slot;\r\n    CLDS_HASH_TABLE_HANDLE hash_table;\r\n    CLDS_HASH_TABLE_HANDLE kvp_hash_table;\r\n    BSI_LOCAL_HANDLE bsi_local = setup_bsi_local_create(&tls_slot, &hash_table, &kvp_hash_table);\r\n    test_fill_index_with_prefix(bsi_local, 1, \"my_block\", 5, \"my_key\");\r\n    test_fill_index_with_prefix(bsi_local, 3, \"not_matching\", 11, \"not_matching\");\r\n    test_fill_index_with_prefix(bsi_local, 7, \"my_other_block\", 5, \"my_other_key\");\r\n    umock_c_reset_all_calls();\r\n\r\n    expect_get_list(kvp_hash_table, 10, 21);\r\n\r\n    umock_c_negative_tests_snapshot();\r\n\r\n    for (size_t i = 0; i < umock_c_negative_tests_call_count(); i++)\r\n    {\r\n        if (umock_c_negative_tests_can_call_fail(i))\r\n        {\r\n            umock_c_negative_tests_reset();\r\n            umock_c_negative_tests_fail_call(i);\r\n\r\n            // act\r\n            int result = bsi_local_get_key_list(bsi_local, \"my\", &key_list);\r\n\r\n            // assert\r\n            ASSERT_ARE_NOT_EQUAL(int, 0, result, \"On failed call %zu\", i);\r\n        }\r\n    }\r\n\r\n    // cleanup\r\n    bsi_local_destroy(bsi_local);\r\n}\r\n\r\nEND_TEST_SUITE(TEST_SUITE_NAME_FROM_CMAKE)\r\n",
        line: 1,
        column: 1,
        offset: 0,
        expected: {
            "",
            "<typedef_name>",
            "#",
        },
    },
)
